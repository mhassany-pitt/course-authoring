{
  "TableCreation1": {
    "name": "Table Creation",
    "description": "Table Creation",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE Students\r\n",
        "comment": "The query to create a new table should start with 'CREATE TABLE' clause followed by the table name. The table name must not conflict with the name of one of the existing tables.\r "
      },
      {
        "line": "     (sid VARCHAR(20) NOT NULL,\r\n",
        "comment": "Column named sid, which is character domain type, has 20 digit space and does not allow NULL value. <br>In the body of the CREATE TABLE clause, the columns of the newly created table are defined. Firstly, every column in the table must have a unique name and domain name is to identify the kind of data that the column stores. Lastly, required data is to determine whether the column contains required data and prevents NULL values from appearing in the column; otherwise, NULL values are allowed.\r\n"
      },
      {
        "line": "      name VARCHAR(20),\r\n",
        "comment": "Each column definition is separated by comma. \r\n"
      },
      {
        "line": "      login VARCHAR(10),\r\n",
        "comment": "VARCHAR data type allows a column to store character strings varying in length from row to row. CHAR, another data type involving charater strings, is for columns holding fixed-length character string. \r\n"
      },
      {
        "line": "      age INTEGER DEFAULT NULL,\r\n",
        "comment": "'age' column is integer domain type and if user does not enter any value, the DBMS system automatically fill the tuple with NULL value by defining DEFAULT value as 'NULL'.\r\n"
      },
      {
        "line": "      gpa REAL DEFAULT 0.00);",
        "comment": " 'gpa' column defaults to 0.00 value. The 'CREATE TABLE' clause ends with closing parenthesis.<br><br>All SQL statements end with semicolon (;)."
      }
    ]
  },
  "TableCreation2": {
    "name": "Primary Key (1)",
    "description": "Primary Key (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE Enrolled\r\n",
        "comment": "This table is to record enrollment information for each student, so both student ID and course ID are defined as the schema of 'Enrolled' table. \r\n"
      },
      {
        "line": "     (sid CHAR(20),\r\n",
        "comment": "'sid' is student ID and 20 digits character type.\r\n"
      },
      {
        "line": "      cid CHAR(20),\r\n",
        "comment": "'cid' is course ID and 20 digits character type.\r\n"
      },
      {
        "line": "      grade CHAR(2),\r\n",
        "comment": "'grade' is grade of each student and 2 digits character type.\r\n"
      },
      {
        "line": "      PRIMARY KEY (sid, cid));",
        "comment": "A student can take a course only once and it is not allowable to take the same course twice. Students have a single grade for each course, because a primary key is specified using both sid and cid. A table's primary key must have a unique value for each row of the table.\r\n"
      }
    ]
  },
  "TableCreation3": {
    "name": "Primary Key and Unique Key",
    "description": "Primary Key and Unique Key",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE Enrolled\r\n",
        "comment": "Students can take a single course only once, not more than once.\r\n"
      },
      {
        "line": "     (eid CHAR(20) NOT NULL, \r\n",
        "comment": "This column is for enrollment ID and it is defined as primary key. Hence, the value should be unique among rows of the table\r\n"
      },
      {
        "line": "      sid CHAR(20),\r\n",
        "comment": "This column is for student ID and it is defined as a part of candidate key which is defined in UNIQUE clause. \r\n"
      },
      {
        "line": "      cid CHAR(20),\r\n",
        "comment": "This course ID is also another part of candidate key which is defined in UNIQUE clause. \r\n"
      },
      {
        "line": "      PRIMARY KEY (eid),\r\n",
        "comment": "If there is more than one same eids, there is integrity error. \r\n"
      },
      {
        "line": "      UNIQUE (sid, cid));\r\n",
        "comment": "UNIQUE keyword is to specify an unique value in every row, but not the primary key of a table. The unique values which can be primary key is called as candidate key. In this example, the pair of cid and sid should be unique. A student whose sid is 1324 can enroll in 'DB Management' course once but not more than once. Howver, the student can take other classes having differnt cids. It is possible to define the UNIQUE key as an attribute constraint. \r\n"
      }
    ]
  },
  "TableCreation4": {
    "name": "Foriegn Key",
    "description": "Foriegn Key",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE Enrolled\r\n",
        "comment": "This table is to store student's enrollment information. There is separate table for 'Students' per se and it's primary key is 'sid.' \r\n"
      },
      {
        "line": "     (sid CHAR(20) NOT NULL,\r\n",
        "comment": "'sid' is student ID. Before being defined as a part of 'Enrolled' table, it is defined in 'Students' table.\r\n"
      },
      {
        "line": "      cid CHAR(20) NOT NULL,\r\n",
        "comment": ""
      },
      {
        "line": "      grade CHAR(2),\r\n",
        "comment": ""
      },
      {
        "line": "      PRIMARY KEY (sid,  cid),\r\n",
        "comment": "For a given student and course,  there is a single grade.\r\n"
      },
      {
        "line": "      FOREIGN KEY (sid)\r\n",
        "comment": "'Sid' in Enrolled table is a foreign key that references 'Students' table. Foreign key clause identify the table's relationships to other tables in the database. Columns forming the relationship is called as foreign key. \r\n"
      },
      {
        "line": "      REFERENCES Students\r\n",
        "comment": "This clause specifies that the foreign key 'sid' is referenced from 'student' table. Keyword 'REFERENCES' is followed by the table name where foreign key is actually defined. Specially, 'REFERENCES' is important part to specify the related table, and the 'FOREIGN KEY' and 'REFERENCES' keyword should not be separated by comma. If there is only table name after it, the DBMS will take the primary key of that table as the foreign key. \r\n"
      },
      {
        "line": "      ON DELETE CASCADE\r\n",
        "comment": "If a row of one or more foreign keys is deleted, the tuple in the foreign key will lose the value to point to. In this example, if the sid, 'ktl123' is deleted in the 'Students' table, the 'ktl123' tuple in this 'Enrolled' is unable to know the student's information any more, because it lose the reference point. Note that deleting a row from referring 'Enrolled' table never poses a problem. The DBMS enforces the default NO ACTION if no rule is explicitly specified. <Br>The CASCADE delete rule tells the DBMS that when a referred row is deleted, all of its pointed rows should automatically be delete from the foreign key.\r\n"
      },
      {
        "line": "      ON UPDATE SET DEFAULT);",
        "comment": "If foreign key is modified by UPDATE statement, the new value should match the value in reference table 'Students'. The SET DEFAULT update rule tells the DBMS that when a value in a referred table is update, the the foreign key values in all of its corresponding rows should also be set to the default value. This rule can be different according the kind of database that you are using. In some DBMS, the restrict rule is defined as SET NULL. In this case, it is impossible to define this restrict rule into primary key of reference table. \r\n"
      }
    ]
  },
  "TableDrop1": {
    "name": "Table Drop",
    "description": "Table Drop",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "DROP TABLE Students;\r\n",
        "comment": "Table named  'Students' is deleted. The schema information and the tuples are removed. With proper permission, you can drop one of your own tables and drop a table owned by another user.\r\n"
      }
    ]
  },
  "TableAlteration1": {
    "name": "Column Addition",
    "description": "Column Addition",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "ALTER TABLE Students\r\n",
        "comment": "This ALTER TABLE statement is to add column title 'firstYear' to the existing 'Students' table.\r\n"
      },
      {
        "line": "      ADD COLUMN firstYear INTEGER;",
        "comment": "The most common use of the ALTER TABLE statement. The column definition clause in the ALTER TABLE statement is just like the one in the CREATE TABLE statement and it works the same way.\r\n"
      }
    ]
  },
  "TableAlteration2": {
    "name": "Column Drop",
    "description": "Column Drop",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "ALTER TABLE Student\r\n",
        "comment": "The ALTER TABLE statement can be used to drop one or more columns from an existing table. Note that dropping a column can pose the data-integrity issues. For example, if you drop a column that is a primary key in some relationship, the foreign key columns that refer to the dropped column become invalid.\r\n"
      },
      {
        "line": "      DROP COLUMN age;\r\n",
        "comment": "DROP COLUMN clause is followed by the column name to be dropped - 'age'\r\n"
      }
    ]
  },
  "DataInsertion1": {
    "name": "Inserting Data (1)",
    "description": "Inserting Data (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "INSERT INTO Students(sid, name, age)\r\n",
        "comment": "Student 'Jamie Done' who is 22 years old and his student id number, '2007001' are inserted into 'Students' table.\r\n"
      },
      {
        "line": "      VALUES('2007001', 'Jamie Done', 22);\r\n",
        "comment": "VALUES clause is to define the inserted value. The order of values should correspond to the column order. Especially, if the column has character domain type, it is embraced by single/double quotation. 'sid' and 'name' column have character domain type, so the value has single quotation. \r\n"
      }
    ]
  },
  "DataDeletion1": {
    "name": "Deleting Data",
    "description": "Deleting Data",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "DELETE\r\n",
        "comment": "DELETE statement is to delete one or more <B>ROWS</b> of data. The keyword 'DELETE' to define the kind of SQL statement and 'from' to specify the target table are mantantory information.\r\n"
      },
      {
        "line": "      FROM Students;\r\n",
        "comment": "It is to delete all rows from 'Students' table\r\n"
      }
    ]
  },
  "DataSelection1": {
    "name": "Selecting One Attribute",
    "description": "Selecting One Attribute",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT sid \r\n",
        "comment": "In SELECT statement, SELECT and FROM clauses are required. The SELECT clause can specify the column(s) in the table to be retrieved. The items are usually specified by a list of columns, separated by commas. In this example, only one column - sid - is selected, hence there is no need to be separated by comma.\r\n"
      },
      {
        "line": "      FROM Student;",
        "comment": "The FROM clause lists the tables that contain the tuple to be retrieved by the query. Data can be drawn from one table or multiple tables.\r\n"
      }
    ]
  },
  "DataSelection2": {
    "name": "Selecting Multiple Attributes",
    "description": "Selecting Multiple Attributes",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT name, login\r\n",
        "comment": "The columns are usually specified by a SELECT list, a list of select items separated by commas. In Student table, 'name' and 'login' attributes in 'Students' table are selected.\r\n"
      },
      {
        "line": "      FROM Student;\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection3": {
    "name": "Selecting All Attributes",
    "description": "Selecting All Attributes",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT * \r\n",
        "comment": "As a convenience, SQL lets you use an asterisk (*) in place of the select list as an abbreviation for 'all columns'.\r\n"
      },
      {
        "line": "      FROM Student;",
        "comment": "'FROM' clause is to define the target table. \r\n"
      }
    ]
  },
  "DataSelection4": {
    "name": "Skipping Duplicates",
    "description": "Skipping Duplicates",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT DISTINCT name \r\n",
        "comment": "DISTINCT keyword eliminates rows of query results in SELECT statement and is located before the column name to erase the duplicate. If the DISTINCT keyword is omitted, SQL does not eliminate duplicate and it has the same result when user use ALL  keyword instead of DISTINCT.\r\n"
      },
      {
        "line": "      FROM Student;",
        "comment": ""
      }
    ]
  },
  "DataSelection5": {
    "name": "Aggregate Functions (1)",
    "description": "Aggregate Functions (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT AVG(gpa) \r\n",
        "comment": "The AVG() aggregate function takes a column of data and computes its average. In this example, 'gpa' column is averaged out and produces a single average value.\r\n"
      },
      {
        "line": "      FROM Student;\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection6": {
    "name": "Selection Condition",
    "description": "Selection Condition",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT Name, Quota, Sales\r\n",
        "comment": "This query retrieve three columns in 'Salesperson' table - Name, Quota, and Sales.\r\n"
      },
      {
        "line": "      FROM Salesperson\r\n",
        "comment": ""
      },
      {
        "line": "      WHERE emp_no = 107;",
        "comment": "Especially this SQL is to retrieve rows of data which are related to the person whose employee number is 107.<br> The WHERE clause is used to limit the rows you want to retrieve. The WHERE clause consists of the WHERE keyword followed by a search condition. The search condition can produce one of the three results. If the search condition is TRUE, the row is included in the query results. If the search condition is FALSE, the row is excluded from the query results. If the search condition has a NULL (unknown) value, the row is excluded from the query results. Basically, the search condition acts as a filter for rows of the table. Rows satisfying the condition pass through the filter and become part of the query results.\r\n"
      }
    ]
  },
  "DataSelection7": {
    "name": "Comparison Condition (1)",
    "description": "Comparison Condition (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT * \r\n",
        "comment": "This query is to find all columns in 'Students' table.\r\n"
      },
      {
        "line": "      FROM Student \r\n",
        "comment": ""
      },
      {
        "line": "      WHERE gpa > 3.2;\r\n",
        "comment": "WHERE condition narrows down the results into students whose gpa is higher than 3.2\r\n"
      }
    ]
  },
  "DataSelection8": {
    "name": "Comparison Condition (2)",
    "description": "Comparison Condition (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT City, Sales, Target\r\n",
        "comment": "This is to choose cities, the sales amount and the target amount from 'Offices' table.\r\n"
      },
      {
        "line": "      FROM Offices \r\n",
        "comment": ""
      },
      {
        "line": "      WHERE Sales < (.8 * Target);\r\n",
        "comment": "This is to find sales less than 80 percent of the target amount. To process this condition, SQL constructs a temporary column containing the value of the expression (.8 * Target), 'Target' is one column in 'Offices' table and then compares them with values in 'Sales' column.\r\n"
      }
    ]
  },
  "DataSelection9": {
    "name": "Comparison Condition (3)",
    "description": "Comparison Condition (3)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT City, Mgr\r\n",
        "comment": "This query is to list cities and the name of managers in 'Offices' tables.\r\n"
      },
      {
        "line": "      FROM Offices \r\n",
        "comment": ""
      },
      {
        "line": "      WHERE Mgr <> 108;\r\n",
        "comment": "The results should exclude the values corresponding to the manager 108. <> expression is to test inequality. That is to say, this condition is to find manager whose number is <b>NOT</b> 108\r\n"
      }
    ]
  },
  "DataSelection10": {
    "name": "Multiple Table Selection (1)",
    "description": "Multiple Table Selection (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT S.name, E.cid \r\n",
        "comment": "This example is to retrieve student's name and course id.\r\n"
      },
      {
        "line": "      FROM Student S, Enrolled E\r\n",
        "comment": "The FROM clause identifies all of the tables that contribute data to the query results. This SQL statement retrieves data from two tables - Students and Enrolled. If a query refers to another user's talbe or the name of the table is very long, it becomes easier to use shorter aliases like S, and E for the two tables. Once table aliases are defined, it is important to specify table alias in column select list. 'name' column is attached to 'Students' table alias S, and 'cid' is attached to 'Enrolled' table alias E.\r\n"
      },
      {
        "line": "      WHERE S.sid = E.sid AND E.grade = \"A\";\r\n",
        "comment": "In condition, table aliases also are used. It compares sid column values in both 'Students' and 'Enrolled'. <br>This condition is to find the students who get A grade.\r\n"
      }
    ]
  },
  "DataSelecton11": {
    "name": "Multiple Comparisons (1)",
    "description": "Multiple Comparisons (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT loan_number \r\n",
        "comment": ""
      },
      {
        "line": "      FROM loan\r\n",
        "comment": ""
      },
      {
        "line": "      WHERE branch_name = Perryridge AND amount > 1200;",
        "comment": "More than one comparison results in conditions can be combined using logical connectives AND, OR and NOT. This condition is to test both if the branch name is Perryridge <b>AND</b> if the amount is greater than 1200.\r\n"
      }
    ]
  },
  "TableCreation5": {
    "name": "Check Constraint (1)",
    "description": "Check Constraint (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE Reserves\r\n",
        "comment": "This is to create table named 'Reserves'. It has three columns - sname, bid, and day.\r\n"
      },
      {
        "line": "    (sname CHAR(10),\r\n",
        "comment": "'sname' column is 10 ditigs character domain type.\r\n"
      },
      {
        "line": "     bid INTEGER,\r\n",
        "comment": "'bid' is integer domain type.\r\n"
      },
      {
        "line": "     day DATE,\r\n",
        "comment": "'day' is date domain type.\r\n"
      },
      {
        "line": "     PRIMARY KEY(bid, day),\r\n",
        "comment": "One boat have to be reserved once in a day.\r\n"
      },
      {
        "line": "     CONSTRAINT noInterlakeRes\r\n",
        "comment": "This is to define CHECK constraint. Before defining constraint, it is capable to specify the constraint name. The following CHECK constraint is named as 'noInterlakeRes'.\r\n"
      },
      {
        "line": "     CHECK\r\n",
        "comment": "CHECK contraint is a search condition that produces a true/false value. When a check constraint is specified for a column, the DBMS authomatically checks the value of that column each time a new row is inserted or a row is updated to ensure that the search condition is true. A column check constraint is specified as part of the column definition within the CREATE TABLE statement.\r\n"
      },
      {
        "line": "      ('Interlake' <>\r\n",
        "comment": "In this example, CHECK constraint named 'noInterlakeRes' is to check whether the name of boat ('bname') that a person want to reserve is 'Interlake'. It is to limit the reservation of 'Interlake' boat.\r\n"
      },
      {
        "line": "             (SELECT B.bname\r\n",
        "comment": "This subquery is to specify the condition should be checked for 'Interlake' column. This subquery is to read boat name from 'boats' table. \r\n"
      },
      {
        "line": "              FROM boats B\r\n",
        "comment": ""
      },
      {
        "line": "              WHERE B.bid = bid)));\r\n",
        "comment": "This is to read boat name in 'boats' table corresponding to the boat id. \r\n"
      }
    ]
  },
  "TableCreation6": {
    "name": "Check Constraint (2)",
    "description": "Check Constraint (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE Sailors\r\n",
        "comment": "This example is to define 'Sailors' table. There are four columns - sid, sname, rating, and age.\r\n"
      },
      {
        "line": "    (sid INTEGER,\r\n",
        "comment": ""
      },
      {
        "line": "     sname CHAR(10),\r\n",
        "comment": ""
      },
      {
        "line": "     rating INTEGER,\r\n",
        "comment": ""
      },
      {
        "line": "     age REAL,\r\n",
        "comment": ""
      },
      {
        "line": "     PRIMARY KEY (sid),\r\n",
        "comment": ""
      },
      {
        "line": "     CHECK (rating >= 1 AND rating <= 10));\r\n",
        "comment": "Especially, the value of 'rating' is restricted to the value from 1 to 10. When a check constraint is specified for a column the DBMS authomatically checks the value of that column each time a new row is inserted or a row is updated to ensure that the search condition is true.\r\n"
      }
    ]
  },
  "TableCreation7": {
    "name": "Assertion Creation (1)",
    "description": "Assertion Creation (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE sailors\r\n",
        "comment": "This example is to create table for sailors and everything to insert sailor it is required to check whether the sum of the number of sailors and the number of boats are not exceeded 100. <b>** This example is connected to the next example.</b> \r\n"
      },
      {
        "line": "   (sid INTEGER,\r\n",
        "comment": ""
      },
      {
        "line": "    sname CHAR(10),\r\n",
        "comment": ""
      },
      {
        "line": "    rating INTEGER,\r\n",
        "comment": ""
      },
      {
        "line": "    age REAL,\r\n",
        "comment": ""
      },
      {
        "line": "    PRIMARY KEY (sid),\r\n",
        "comment": ""
      },
      {
        "line": "    CHECK\r\n",
        "comment": "This example is to specify the total number of sailors and boats should be less 100. However, this example is WRONG. This check constraint which checks both 'sailor' and 'boats' tables belongs to 'sailors' table itself recursively. If sailors is empty, the number of Boats tuples can be anything!\r\n"
      },
      {
        "line": "    ((SELECT COUNT(S.sid) \r\n",
        "comment": "<b>This first example is WRONG.</b> If sailors is empty, the number of Boats tuples can be anything! It returns the number sailor id. The most nested query is executed firstly. \r\n"
      },
      {
        "line": "     FROM sailor S) + \r\n",
        "comment": "Two separate queries are linked using summation sign. Both query results are sum up. \r\n"
      },
      {
        "line": "    (SELECT COUNT(B.sid) \r\n",
        "comment": "This query returns the number of boats.\r\n"
      },
      {
        "line": "     FROM boats B)\r\n",
        "comment": ""
      },
      {
        "line": "     < 100));\r\n",
        "comment": "The summed results of two subqueries is compared with '100' and if the value is less than 100, the condition is satisfied. \r\n"
      }
    ]
  },
  "DataInsertion2": {
    "name": "Inserting Data (2)",
    "description": "Inserting Data (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "INSERT INTO Students(sid, name, login, age, gpa)\r\n",
        "comment": "'INTO' clause which is mantantory in 'INSERT' clause is to specify the table and columns to store data. The order of inserted data should be matched with the order of each column specified in SQL statement. If the column names are omitted, the data are inserted by the column order of table definition.\r\n"
      },
      {
        "line": "      VALUES('53688', 'Smith', 'smith@ee', 18, 3.2);",
        "comment": "'VALUES' keyword is necessary to define the inserted data. The value for sid, name, or login whose domain types are character is surrounded by single quotation mark.\r\n"
      }
    ]
  },
  "DataInsertion3": {
    "name": "Inserting Data (3)",
    "description": "Inserting Data (3)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "INSERT INTO account\r\n",
        "comment": "This examples is to create a $200 saving account for all loan customers of the Perryridge branch. Rather than specifying data by user, this sql is to insert data read from another table. <BR> 'account' table is defined as 'account_number', 'branch_name', and 'balance'. By this order, the data is stored.\r\n"
      },
      {
        "line": "      SELECT loan_no, branch_name, 200\r\n",
        "comment": "Before executing insertion, this 'SELECT' is executed to choose the data to be stored in 'account' table. From 'loan' table, instances in loan_no and branch_name columns are selected and for the last 'balance' column in 'account' table, constance 200 is defined. Hence, all selected account has the same $200 balance.\r\n"
      },
      {
        "line": "          FROM loan\r\n",
        "comment": ""
      },
      {
        "line": "          WHERE branch_name = 'Perryridge';\r\n",
        "comment": "This condition is to limit the retrieved data to 'Perryridge' branch. The domain type of 'branch_name' is character, so the compared value is specified by single quotation mark.\r\n"
      }
    ]
  },
  "DataInsertion4": {
    "name": "Inserting Data (4)",
    "description": "Inserting Data (4)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "INSERT INTO depositor\r\n",
        "comment": "The data is inserted into 'depositor' table. \r\n"
      },
      {
        "line": "      SELECT customer_name, loan_no\r\n",
        "comment": "To assign created accounts to customers belonging to 'Perryridge', 'customer_name' in borrower table and 'loan_no' in loan table is selected. The data stored in the target 'depositor' table are these two data.\r\n"
      },
      {
        "line": "           FROM loan, borrower\r\n",
        "comment": "'customer_name' is from 'borrower' table and 'loan_no' is from 'loan' table. \r\n"
      },
      {
        "line": "           WHERE branch_name ='Perryridge'\r\n",
        "comment": "This is to choose customer from 'Perryridge' branch.\r\n"
      },
      {
        "line": "              AND loan.accont_no = borrower.account_no;",
        "comment": "This is to check whether each borrower has loan account.\r\n"
      }
    ]
  },
  "DataUpdate1": {
    "name": "Updating Data (2)",
    "description": "Updating Data (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "UPDATE Students S\r\n",
        "comment": "The 'UPDATE' keyword is followed by table 'Students' and the table is renamed as 'S' because it is little bit long to use.\r\n"
      },
      {
        "line": "     SET S.gpa = S.gpa*1.01\r\n",
        "comment": "The SET clause is mandantory in UPDATE statement and it specifies which columns are to be updated. Because table name is renamed as 'S' the column name is assigned by it using dot. Each instance in 'gpa' is read, calculates 101% of the value, and is reassigned to new value.\r\n"
      },
      {
        "line": "     WHERE S.gpa >= 3.3;\r\n",
        "comment": "Not all instances are updated and gpas which is just equal or higher than 3.3 are selected.\r\n"
      }
    ]
  },
  "DataUpdate2": {
    "name": "Updating Data (3)",
    "description": "Updating Data (3)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "UPDATE Students S\r\n",
        "comment": "The UPDATE statement modifies the values of one or more columns in selected rows of table.\r\n"
      },
      {
        "line": "     SET S.age = S.age+1 AND S.gpa = S.gpa-1\r\n",
        "comment": "The SET clause specifies a list of assignments and each assignment defines the value to be updated.\r\n"
      },
      {
        "line": "     WHERE S.sid = 5368;\r\n",
        "comment": "A single row or multiple rows can be updated up to whether condition is defined in the SQL statement or not.\r\n"
      }
    ]
  },
  "DataUpdate3": {
    "name": "Updating Data (1)",
    "description": "Updating Data (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "UPDATE Salesrep\r ",
        "comment": "The WHERE clause can be omitted if all data in a certain column should be changed. In this example, all quota data of sales representative are increased 5%.\r "
      },
      {
        "line": "     SET quota = 1.05 * quota;\r\n",
        "comment": "Quotas of all sales representatives are added 5%.\r\n"
      }
    ]
  },
  "DataUpdate4": {
    "name": "Updating with condition",
    "description": "Updating with condition",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "UPDATE Customers\r\n",
        "comment": "This example shows that not only one, more than one condition can be defined in one SQL.\r\n"
      },
      {
        "line": "     SET cust_rep = 102\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE cust_rep IN (105, 106, 107);\r\n",
        "comment": "IN is the set membership test. It tests whether a data value matches one of a list of target values. In this example, if cust_rep is one of 105,106, or 107, the condition turns out TRUE.\r\n"
      }
    ]
  },
  "DataUpdate5": {
    "name": "Updating with subquery",
    "description": "Updating with subquery",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "UPDATE Customers\r\n",
        "comment": ""
      },
      {
        "line": "     SET credit_limit = credit_limit + 5000.00\r\n",
        "comment": "Before executing update, subquery in parenthesis is executed to limit the data. After then, this addition of $5,000 to current credit limit is updated.\r\n"
      },
      {
        "line": "     WHERE cust_num IN\r\n",
        "comment": "WHERE clause choose one of the customers in the results of subquery. IN is the common search condition. It tests whether a data value matches one of the list of value in the right part. It compares instances in 'cust_num' to the results of subquery.\r\n"
      },
      {
        "line": "          (SELECT DISTINCT cust\r\n",
        "comment": "This SELECT query is subquery, a query within a query. This query is to retrieve the list of customers who bought product in amout of 25000. When choose some data collectively, it is efficient to use subquery.  Subquery let users select rows to update based on information contains in other tables.\r\n"
      },
      {
        "line": "           FROM orders \r\n",
        "comment": ""
      },
      {
        "line": "           WHERE amount > 25000.00);\r\n",
        "comment": ""
      }
    ]
  },
  "DataDeletion2": {
    "name": "Deleting with Condition (1)",
    "description": "Deleting with Condition (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "DELETE FROM account\r\n",
        "comment": "The target table 'account' is specified. \r\n"
      },
      {
        "line": "     WHERE branch_name IN\r\n",
        "comment": "IN is set membership test. It tests whether a data value matches on of a list of target values. The IN in this line compares branch names with the subquery results that are branches in 'Brookly'.\r\n"
      },
      {
        "line": "         (SELECT branch_name\r\n",
        "comment": "In this example, the subquery to find branch located in 'Brooklyn' is used and by comparing the list of results, they choose the accounts opened in the branches.\r\n"
      },
      {
        "line": "          FROM branch\r\n",
        "comment": ""
      },
      {
        "line": "          WHERE branch_city = 'Brooklyn');\r\n",
        "comment": "WHERE clause is to choose certain rows of data by condition. 'WHERE' keyword is followed by the comparison and this example is to choose the rows which is located in 'Brookly' as the branch city and delete the information. 'branch_city' column has character domain type, so in order to compare the value, the test value should be character too. In addition, the test value 'Brookly' is embraced with single quotation, because it is character. \r\n"
      }
    ]
  },
  "DataDeletion3": {
    "name": "Deleting with Condition (2)",
    "description": "Deleting with Condition (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "DELETE FROM account\r\n",
        "comment": "The target table is 'acount.'\r\n"
      },
      {
        "line": "     WHERE balance < \r\n",
        "comment": "The order of this query execution is firstly, the subquery to calculate the average amount of all account is executed and then the balance of each account is compared with the average. Lastly, the corresponding account is deleted. <br>To limit the data, balance data is compared with the average balance in subquery result.\r\n"
      },
      {
        "line": "         (SELECT AVG(balance)\r\n",
        "comment": "This subquery is to calculate average balance of each account.\r\n"
      },
      {
        "line": "          FROM account);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection12": {
    "name": "Arithmetic Expression",
    "description": "Arithmetic Expression",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT loan_number, branch_name, amount * 100\r\n",
        "comment": "By directly doing arithmetic calculation such *, +, -, / to value of column, it is possible to recalculate the value. But the value stored in the database is not changed and the returned values are changed.\r\n"
      },
      {
        "line": "     FROM loan;",
        "comment": ""
      }
    ]
  },
  "DataSelection13": {
    "name": "Multiple Comparisons (2)",
    "description": "Multiple Comparisons (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT customer_no, borrower.loan_no, amount\r\n",
        "comment": "This query specify column 'loan_no' should be read from 'borrower' table. The reason why this column name is specified along with the table name is that both 'borrower' and 'loan' table have the column. If the table name is not specified, the column is read from the table where the column belongs to exclusively.\r\n"
      },
      {
        "line": "     FROM borrower, loan\r\n",
        "comment": "Data is read from these two tables.\r\n"
      },
      {
        "line": "     WHERE borrower.loan_no = loan.loan_no AND branch_name = 'Perryridge';\r\n",
        "comment": "In order to loan amount attached to each customer, it tests match betwee two values in two tables. After then, loans from Perryridge branch are retrieved. The data met these two condition should be retrieved because of the AND logic.\r\n"
      }
    ]
  },
  "DataSelection14": {
    "name": "Range Test (1)",
    "description": "Range Test (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT loan_number \r\n",
        "comment": ""
      },
      {
        "line": "     FROM loan\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE amount BETWEEN 2000 AND 100000;\r\n",
        "comment": "BETWEEN clause is range test operator. The range test checks whether a data value lies between two specified values. The left part of AND keyword is the low ends of value and right part is high ends of the range to be tested.  This is completely equivalent to (amount >= 2000) AND (amount <=100000)\r\n"
      }
    ]
  },
  "DataSelection15": {
    "name": "Range Test (2)",
    "description": "Range Test (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT order_no, date, product, amount\r\n",
        "comment": ""
      },
      {
        "line": "     FROM orders\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE date BETWEEN '01-OCT-06' AND '31-DEC-06';\r\n",
        "comment": "Range test can be applied to date domain type, as well. This is equivalent to  (date >= '01-OCT-06') AND (date <= '31-DEC-06')\r\n"
      }
    ]
  },
  "DataSelection16": {
    "name": "Multiple Table Selection (2)",
    "description": "Multiple Table Selection (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT customer_name, T.loan_no, S.amount\r\n",
        "comment": ""
      },
      {
        "line": "     FROM borrower AS T, loan AS S\r\n",
        "comment": "Table aliases are defined in the FROM clause via the use of the AS clause. If the table name is too long, it is convenient to shorter alias name. If a query refers to another user's table, the table name can also have alias.\r\n"
      },
      {
        "line": "     WHERE T.loan_no = S.loan_no;\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection17": {
    "name": "String Operation",
    "description": "String Operation",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT customer_name \r\n",
        "comment": ""
      },
      {
        "line": "     FROM customer\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE customer_street LIKE '%Main%';",
        "comment": "SQL includes a substring-matching operator for comparisons on character strings. The operator \"like\" uses patterns that are described using two special characters: <ul><li>percent(%): The % character matches any substring.<li>underscore(_): the _ character matches any character.</ul><br>The percent sign (%) wildcard character matches any sequence of zero or more character. Wherever the 'Main' charater is located in the customer street data, it turns out to be true. Any of the following data  would match the pattern. <br>Pittsburgh Main Street, Chrismain Blvd, Main Government Bulding, Aid first Main.\r\n"
      }
    ]
  },
  "DataSelection18": {
    "name": "Alphabetic Order",
    "description": "Alphabetic Order",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT DISTINCT customer_name \r\n",
        "comment": "DISTINCT is to eliminated the same row of results. So the customer having loan will be displayed alphabetically without duplication.\r\n"
      },
      {
        "line": "     FROM borrower AS T, loan AS S\r\n",
        "comment": "Table aliases are defined for both borrower and loan table. The table alias can be used if the table name is too long to write the whole name or for the convenience of query programmer\r\n"
      },
      {
        "line": "     WHERE T.loan_no = S.loan_no\r\n",
        "comment": "Loan number in borrower table is matched with loan number in loan table.\r\n"
      },
      {
        "line": "     ORDER BY customer_name;",
        "comment": "By using ORDER BY clause, you can define column that you want to list in order.  DESC clause specifies descending order and ASC specifies ascending order and these DESC or ASC is placed right next to the column name; ascending order is the default.\r\n"
      }
    ]
  },
  "DataSelection19": {
    "name": "Combining Query Results (1)",
    "description": "Combining Query Results (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "(SELECT customer_name \r\n",
        "comment": "The first SELECT statement is to choose customers who have account.\r\n"
      },
      {
        "line": "     FROM depositor)\r\n",
        "comment": ""
      },
      {
        "line": "     UNION\r\n",
        "comment": "The UNION operation is to combine the results of two or more queries into a single table of query results. The major restriction of UNION operation is that the two tables must contain the same number of columns. It is also important that the domain type of each column in both tables should be identical. Because the UNION operation combines two sets of query results, it would tend to produce duplicate rows. However, <u>by default</u>, the UNION operation eliminates duplicate rows as part of its processing. If you want to retain duplicate rows, you can specify the ALL keyword following the UNION like 'UNION ALL.' "
      },
      {
        "line": "(SELECT customer_name \r\n",
        "comment": "Second SELECT statement is to find customers who have loan\r\n"
      },
      {
        "line": "     FROM borrower);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection20": {
    "name": "Combining Query Results (2)",
    "description": "Combining Query Results (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "(SELECT customer_name\r\n",
        "comment": "This first query is to find customers having account.\r\n"
      },
      {
        "line": "     FROM depositor)\r\n",
        "comment": ""
      },
      {
        "line": "     INTERSECT\r\n",
        "comment": "The INTERSECT operation produces a single table of the query results appearing in both input tables. It is important that the two tables must contain the same number of columns and the domain type of each column in both tables should be identical. <u>By default</u>, the INTERSECT operation eliminates duplicate rows as part of its processing. If you want to retain duplicate rows, you can specify the ALL keyword following the INTERSECT like 'INTERSECT ALL'\r\n"
      },
      {
        "line": "(SELECT customer_name \r\n",
        "comment": "This query is to find customers having loan.\r\n"
      },
      {
        "line": "     FROM borrower);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection21": {
    "name": "Combining Query Results (3)",
    "description": "Combining Query Results (3)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "(SELECT customer_name \r\n",
        "comment": "The first query is to find customers having account\r\n"
      },
      {
        "line": "     FROM depositor)\r\n",
        "comment": ""
      },
      {
        "line": "     EXCEPT\r\n",
        "comment": "The EXCEPT operation produces a single table containing the rows that appear in the first table but that do not appear in another table. It is important that the two tables must contain the same number of columns and the domain type of each column in both tables should be identical. <u>By default</u>, the EXCEPT operation eliminates duplicate rows as part of its processing. If you want to retain duplicate rows, you can specify the ALL keyword following the EXCEPT like 'EXCEPT ALL'\r\n"
      },
      {
        "line": "     (SELECT customer_name\r\n",
        "comment": "This second query is to find customers having loan\r\n"
      },
      {
        "line": "     FROM borrower);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection22": {
    "name": "Aggregate Functions (2)",
    "description": "Aggregate Functions (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT AVG(balance)\r\n",
        "comment": "The AVG() aggregate function computes the average of a column of data values and retrieve the calculated average value only. The data in the column must have a numeric type.\r\n"
      },
      {
        "line": "     FROM account\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE branch_name = 'Perryridge';",
        "comment": "This condition is to limit the retrieved data to 'Perryridge' branch.\r\n"
      }
    ]
  },
  "DataSelection23": {
    "name": "Aggregate Functions (3)",
    "description": "Aggregate Functions (3)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT COUNT(*) \r\n",
        "comment": "The COUNT() aggregate function calculate the total number of tuples. If the column name is specified as a part of the operation, it counts the number of values in a column. For example, COUNT(customer_name) is to calculate the total number of 'customer_name' values. COUNT(*) is to count rows of query results.\r\n"
      },
      {
        "line": "     FROM customer;\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection24": {
    "name": "Aggregate Functions (4)",
    "description": "Aggregate Functions (4)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT COUNT(DISTINCT customer_name) \r\n",
        "comment": "DISTINCT keyword is to eliminate duplicate in result, so unique customer names are just retrieved. After handling duplicate, the COUNT() aggregate function calculates the total number of values in customer_name column.\r\n"
      },
      {
        "line": "     FROM depositor;\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection25": {
    "name": "Grouped Queries",
    "description": "Grouped Queries",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT branch_name, AVG(balance)\r\n",
        "comment": "By using group by, the results are grouped by branch name.\r\n"
      },
      {
        "line": "     FROM account\r\n",
        "comment": ""
      },
      {
        "line": "     GROUP BY branch_name;",
        "comment": "GROUP BY clause is to group the data from its source tables and produce a single summary row for each row group. In this example, the results are grouped by the specified 'branch_name'.\r\n"
      }
    ]
  },
  "DataSelection26": {
    "name": "Grouped Queries with Condition",
    "description": "Grouped Queries with Condition",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT branch_name, AVG(balance)\r\n",
        "comment": ""
      },
      {
        "line": "     FROM account\r\n",
        "comment": ""
      },
      {
        "line": "     GROUP BY branch_name\r\n",
        "comment": "The result data is grouped and summarized for each branch_name."
      },
      {
        "line": "     HAVING AVG(balance) > 600;\r\n",
        "comment": "Just as the WHERE clause, the HAVING clause can be used to select and reject row groups. <br>As specified by 'group by', the balance data is group and subtotalled up by branch_name and then the average of subtotal balance is calculated. If the average of subtotal is greater than 600, the data is retrieved. The format of the HAVING clause parallels that of the WHERE clause, but this HAVING clause can be used as a GROUP."
      }
    ]
  },
  "DataSelection27": {
    "name": "Checking Null Values",
    "description": "Checking Null Values",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT loan_no \r\n",
        "comment": ""
      },
      {
        "line": "     FROM loan\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE amount IS NULL;\r\n",
        "comment": "IS NULL predicate is to handle null value directly as a comparison. If the compared value is null, it results TRUE and vice versa. NULL is just a keyword that the value is unknown. Even if the comparison test 'amount = null' were legal, the rules can be different from what you might expect. It is because this comparison is like this, 'Known Value = Unknown Value'. Hence, it is impossible to judge whether it is TRUE or FALSE."
      }
    ]
  },
  "DataSelection28": {
    "name": "Nested Subqueries (1)",
    "description": "Nested Subqueries (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT DISTINCT customer_name \r\n",
        "comment": "The subquery covered by round parenthesis is calculated at first and then using set membership test, the results are compared with main query results. <Br>By specifying DISTINCT, duplications in customer_name are eliminated.\r\n"
      },
      {
        "line": "     FROM borrower\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE customer_name IN \r\n",
        "comment": "IN set membership test is to see whether a data value matches one of a list of target values. For instance, 'X IN (A, B, C)' is completely equivalent to '(X = A) OR (X = B) OR (X = C)'. In this example, customer name is tested with the customer names in 'depositor' table.\r\n"
      },
      {
        "line": "          (SELECT customer_name \r\n",
        "comment": "SQL provides a mechanism for nesting subqueries. A subquery is a SELECT-FROM-WHERE statement or statement containing GROUP BY and HAVING that is nested within another query. <br>This query is to find customer name having account.\r\n"
      },
      {
        "line": "           FROM depositor);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection29": {
    "name": "Nested Subqueries (2)",
    "description": "Nested Subqueries (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT DISTINCT customer_name \r\n",
        "comment": "Customers having account are selected in subquery at first and then, customers having loan are compared with the results of subquery."
      },
      {
        "line": "     FROM borrower\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE customer_name NOT IN \r\n",
        "comment": "You can check whether the data value does not match any of the target value by using the NOT IN form of the condition test."
      },
      {
        "line": "          (SELECT customer_name \r\n",
        "comment": "This subquery is to find customers having account."
      },
      {
        "line": "           FROM depositor);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection30": {
    "name": "Comparing Subquery Results (1)",
    "description": "Comparing Subquery Results (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT branch_name \r\n",
        "comment": ""
      },
      {
        "line": "     FROM branch\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE assets > SOME\r\n",
        "comment": "The SOME test is used in conjunction with one of the six SQL comparison operators (=, <>, <, <=, >, >=) to compare the test value with the results of subquery. If any of the individual comparisons yield a TRUE result, the SOME test results a TRUE results. SOME and ANY are equivalent. In this example, asset of every branch is compared with every assets of branch in 'Brooklyn'.\r\n"
      },
      {
        "line": "          (SELECT assets \r\n",
        "comment": "This is to find assets of branch opened in 'Brooklyn'.\r\n"
      },
      {
        "line": "           FROM branch \r\n",
        "comment": ""
      },
      {
        "line": "          WHERE branch_city = 'Brooklyn');\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection31": {
    "name": "Comparing Subquery Results (2)",
    "description": "Comparing Subquery Results (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT branch_name \r\n",
        "comment": ""
      },
      {
        "line": "     FROM branch\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE assets > ALL\r\n",
        "comment": "The ALL test is used in conjunction with one of the six SQL comparison operators (=, <>, <, <=, >, >=) to compare test value to the results of subquery. If all of the individual comparsions yield a TRUE results, the ALL test returns a TRUE result. In this example, the asset of each branch is compared with all assets of 'Brooklyn' branches and the ALL values of 'Brooklyn' branches are smaller than the asset, it is retrieved.\r\n"
      },
      {
        "line": "          (SELECT assets \r\n",
        "comment": "This is to find assets of branch opened in 'Brooklyn'.\r\n"
      },
      {
        "line": "           WHERE branch_city = Brooklyn);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection32": {
    "name": "Aggregating Subquery",
    "description": "Aggregating Subquery",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT branch_name \r\n",
        "comment": "Firstly, average value of all branches are calculated in subquery and then using ALL test, the average account value of each branch is compared with the subquery results."
      },
      {
        "line": "     FROM account\r\n",
        "comment": "This to find the branches with the largest average account balance. "
      },
      {
        "line": "     GROUP BY branch_name\r\n",
        "comment": "This is to group the account balance according to the branch."
      },
      {
        "line": "     HAVING AVG(balance) >= ALL \r\n",
        "comment": "This is condition to find the largest average account value using ALL test. Just as the WHERE clause can be used to select and reject the individual rows, the HAVING clause can be used to select and reject row groups. The format of the HAVING clause parallels that of the WHERE clause, but this HAVING clause can be used as a GROUP search conditions. To perform this >= comparison, the balance is grouped by the branch_name and the average value is calculated. The calculated single value is compared with ALL average value of each branch and if they are smaller or equal to the single value, it yields TRUE."
      },
      {
        "line": "          (SELECT AVG(balance) \r\n",
        "comment": "This is to calculated average account value of each branch."
      },
      {
        "line": "           FROM account \r\n",
        "comment": ""
      },
      {
        "line": "           GROUP BY branch_name);\r\n",
        "comment": "This is to specify to group the balance value by branch and then the grouped value is calculated in AVG function."
      }
    ]
  },
  "DataSelection33": {
    "name": "Derived Relations",
    "description": "Derived Relations",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT branch_name, avg_balance\r\n",
        "comment": "In this example, an derived subquery is used in the FROM clause.  The column names used in this main query is not from the original 'account' table. It is aliase name from the derived subquery relation.\r\n"
      },
      {
        "line": "     FROM\r\n",
        "comment": "SQL allows a subquery expression to be used in the FROM clause and this is the derived relations.\r\n"
      },
      {
        "line": "          (SELECT branch_name, AVG(balance)\r\n",
        "comment": "This subquery is to select branch name and average account value of branch.\r\n"
      },
      {
        "line": "           FROM account\r\n",
        "comment": "Note that we do not need to use the HAVING clause, since we compute the temporary relation <i>branch_avg</i> in the FROM clause, and the attributes of <i>branch_avg</i> can be used directly in the WHERE clause.\r\n"
      },
      {
        "line": "           GROUP BY branch_name)\r\n",
        "comment": "This GROUP BY clause is used in derived relation.\r\n"
      },
      {
        "line": "           AS branch_avg(branch_name, avg_balance))\r\n",
        "comment": "The derived subquery and the two columns are renamed using tuple variables, AS. Hence, the whole subquery is 'branch_avg', the first column is 'branch_name' and the second column is 'avg_balance'.\r\n"
      },
      {
        "line": "    WHERE avg_balance > 1200;\r\n",
        "comment": "In order to limit the value of avg_balance column WHERE clause is used. Because the derived relations is temporal table and the test value, avg_balance, is read from the table directly, there is no need to used HAVING comparison.\r\n"
      }
    ]
  },
  "DataSelection34": {
    "name": "View Creation (1)",
    "description": "View Creation (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE VIEW v AS \r\n",
        "comment": "A VIEW is a virtual table in the database whose contents are defined by a query. To users, the VIEW appears like a real table, but the rows and columns of data visible through the VIEW are the query results produced by the query defining the VIEW. The SQL for new view should start with 'CREATE VIEW' and the name is followed. The view columns are defined after 'AS' keyword."
      },
      {
        "line": "     (SELECT customer_name, loan_no \r\n",
        "comment": "This is the query to define view. Customers having loan and loan number are selected."
      },
      {
        "line": "      FROM borrower, loan\r\n",
        "comment": "When DBMS encounters a reference to  a view in a SQL statement, it finds the definition of the view and then the DBMS translate the request that references the view into an equivalent request against the source tables of the view and carries out the equivalent requiest."
      },
      {
        "line": "      WHERE borrower.loan_no = loan.loan_no);\r\n",
        "comment": "Views provide a variety of benefits and can be useful in many different types of databases. Views provide these major benefits: <ul><li>Security: Each user can be given permission to access the database only through a small set of views.</li><li>Query simplicity: A view can data from several different tables and present it a s a single table, turning multitable queries into single-table queries</li><li>Structural simplicity: Views can give a user a personalized view of the database structure.</li><li>Insulation from change: A view can present a consistent, unchanged image of the structure of the database, even if the underlying source tables are split, restructured, or renamed</li><li>Data Integrity: If data is accessed and entered through a view, the DBMS can automatically check the data to ensure that it meets specified integrity constraints</li></ul>. While views provide substantial advantages, there are also two major disadvantages: <ul><li>Performance: If the view is defined by a complex multitable query, then even a single query against the view becomes a complicated join, and it may take a long time to complete</li><li>Update restrictions: Updating rows of a view is possible for simple views, but more complex views cannot be updated; they are ready-only.</li></ul>"
      }
    ]
  },
  "DataSelection35": {
    "name": "View Creation (2)",
    "description": "View Creation (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE VIEW all_customer AS \r\n",
        "comment": "A VIEW is a virtual table in the database whose contents are defined by a query. To users, the VIEW appears like a real table, but the rows and columns of data visible through the VIEW are the query results produced by the query defining the VIEW. \r\n"
      },
      {
        "line": "    (SELECT branch_name, customer_name\r\n",
        "comment": "This is the first query is to find the customers having account and the branch.\r\n"
      },
      {
        "line": "        FROM depositor, account\r\n",
        "comment": ""
      },
      {
        "line": "        WHERE depositor.account_no = account.account_no)\r\n",
        "comment": ""
      },
      {
        "line": "     UNION\r\n",
        "comment": "VIEW is for multi-table combination as a one table. Hence, by using UNION it is possible to add up two different SQL query results. UNION is to combine two results from separate queries into one results without duplicate.\r\n"
      },
      {
        "line": "    (SELECT branch_name, customer_name\r\n",
        "comment": "This is the second query to find the customers having loan and the branch.\r\n"
      },
      {
        "line": "        FROM borrower, loan\r\n",
        "comment": ""
      },
      {
        "line": "        WHERE borrower.loan_no = loan.loan_no);\r\n",
        "comment": ""
      }
    ]
  },
  "DataSelection36": {
    "name": "Grouping and aggregating (1)",
    "description": "Grouping and aggregating (1)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT b.bid, COUNT(*) AS account\r\n",
        "comment": ""
      },
      {
        "line": "     FROM boats B, reserves R\r\n",
        "comment": "'boats' and 'reserves' tables are renamed as B and R, respectively."
      },
      {
        "line": "     WHERE R.bid = B.bid AND b.color = red\r\n",
        "comment": "This condition tests two parts. Firstly, it tests whether the boats have been reserved by match the boat's bid with the bid in the 'reserves'. Secondly, the boat' color is limited to red."
      },
      {
        "line": "     GROUP BY B.bid;\r\n",
        "comment": "The COUNT function is working with this GROUP BY clause. In order to calculated the number of rows, the results are group by the bid. And then, the COUNT function is performed."
      }
    ]
  },
  "DataSelection37": {
    "name": "Grouping and aggregating (2)",
    "description": "Grouping and aggregating (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT S.rating, MIN (S.age)\r\n",
        "comment": ""
      },
      {
        "line": "     FROM Sailor S\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE S.age > 18\r\n",
        "comment": "Not all sailors are taken into consideration. Sailors older than 18 years are selected.\r\n"
      },
      {
        "line": "     GROUP BY S.rating\r\n",
        "comment": "The sailors' ratings are grouped.\r\n"
      },
      {
        "line": "     HAVING 1 < \r\n",
        "comment": "This query firstly limit ratings having at least two sailors in the rating. The total number of each ratings that sailors are beloning to is compared with 1.\r\n"
      },
      {
        "line": "         (SELECT COUNT(*) \r\n",
        "comment": "This subquery is to count the number of sailors belonging to each ratings.\r\n"
      },
      {
        "line": "          FROM Sailors S2\r\n",
        "comment": ""
      },
      {
        "line": "          WHERE S.rating = S2.rating);\r\n",
        "comment": "The ratings in Sailors table is matched with grouped ratings.\r\n"
      }
    ]
  },
  "DataSelection38": {
    "name": "Grouping and aggregating (3)",
    "description": "Grouping and aggregating (3)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT S.rating \r\n",
        "comment": ""
      },
      {
        "line": "     FROM Sailor S\r\n",
        "comment": ""
      },
      {
        "line": "     WHERE S.age = \r\n",
        "comment": ""
      },
      {
        "line": "         (SELECT MIN (AVG(S2.age)) \r\n",
        "comment": "This example is WRONG, because aggregate operations cannot be nested. This query tried to calculate average age of sailors and minimum value of it again. AVG function cannot be nested by another aggregate function.\r\n"
      },
      {
        "line": "          FROM sailors S2);",
        "comment": ""
      }
    ]
  },
  "TableCreation8": {
    "name": "Assertion Creation (2)",
    "description": "Assertion Creation (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE ASSERTION smallClub\r\n",
        "comment": "The previous example ('Assertion Creation (1)') checks the values within itself and it is inappropriate. This example explains ASSERTION as the right solution; not associated with either table. An ASSERTION is a database constraint that restricts the contents of the database as a whole. Like a CHECK constraint, an assertion is specified as a search condition. But the difference of ASSERTION with CHECK constraint is that the search condition in an assertion can restrict the contents of multiple tables and the data relationships among them. For that reaon, an ASSERTION is specified as part of the overall database definition, via CREATE ASSERTION statement.\r\n"
      },
      {
        "line": "    CHECK\r\n",
        "comment": "'CHECK' keyword is mandantory for creating assertion. \r\n"
      },
      {
        "line": "    ((SELECT COUNT(S.sid) \r\n",
        "comment": "In this example,  both sailor and boats are target tables to be compared as a search condition. This returns the number of sailors. \r\n"
      },
      {
        "line": "     FROM sailor S) + \r\n",
        "comment": "Two query results are summed up. \r\n"
      },
      {
        "line": "    (SELECT COUNT(B.sid) \r\n",
        "comment": "This query counts the number of boats. \r\n"
      },
      {
        "line": "     FROM boats B)\r\n",
        "comment": ""
      },
      {
        "line": "      < 100));\r\n",
        "comment": "The summed result of two queries is compared with 100 and checks if the value is less than 100. \r\n"
      }
    ]
  },
  "DataSelection40": {
    "name": "Retrieving data from view",
    "description": "Retrieving data from view",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT customer_name\r\n",
        "comment": ""
      },
      {
        "line": "      FROM all_customer\r\n",
        "comment": "The view name 'all_customer' is used in the place of table.\r\n"
      },
      {
        "line": "      WHERE branch_name = 'Perryridge';\r\n",
        "comment": "The results is restricted to the customers belonging to 'Perryridge' branch.\r\n"
      }
    ]
  },
  "DataSelection41": {
    "name": "Aggregating Derived Relations",
    "description": "Aggregating Derived Relations",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "SELECT temp.rating, temp.average\r\n",
        "comment": "To make the previous example properly, derived relations and comparison using WHERE clause can be used. This example is also to select those ratings for which the average age is the minimum over all ratings. 'temp' in front of the each column is the name of derived relation.\r\n"
      },
      {
        "line": "     FROM \r\n",
        "comment": ""
      },
      {
        "line": "        (SELECT S.rating, AVG(S.age) AS avgage\r\n",
        "comment": "This subquery is used with FROM. So it is derived relation. It is to calculate average age of sailors for each ratings. The sailors are grouped by their ratings and the age is averaged over each group. The averaged value is renamed as 'avgage'.\r\n"
      },
      {
        "line": "         FROM sailors S\r\n",
        "comment": ""
      },
      {
        "line": "         GROUP BY S.rating) AS temp\r\n",
        "comment": "The whole derived subquery is renamed as 'temp'. Once the derived relation is renamed, the new name can be used in outer query.\r\n"
      },
      {
        "line": "     WHERE temp.avgage = \r\n",
        "comment": "The avgage value in derived relation is compared with second subquery.\r\n"
      },
      {
        "line": "    (SELECT MIN(temp.avgage) \r\n",
        "comment": "This query is to calculate minimum average value ('avgage') in derived relation, 'temp'.\r\n"
      },
      {
        "line": "     FROM temp);\r\n",
        "comment": ""
      }
    ]
  },
  "TableCreation9": {
    "name": "Primary Key (2)",
    "description": "Primary Key (2)",
    "language": "sql",
    "author": "admin",
    "lines": [
      {
        "line": "CREATE TABLE course\r\n",
        "comment": "This example is to create table for course and course ID and course name are the information to be stored.\r\n"
      },
      {
        "line": "     (cid CHAR(20) NOT NULL PRIMARY KEY,\r\n",
        "comment": "Course ID is defined as 'cid'. This column is not allowed to have null value. <BR><BR>Primary key specifies an unique identifier for each row of the table. That is to say, there is not more than one course IDs that are the same. In addition, the column defined as primary key is not allowed to be null.\r\n"
      },
      {
        "line": "      cname CHAR(40));\r\n",
        "comment": ""
      }
    ]
  },
  "TableCreation1_version_1": {
    "name": "TableCreation_version_1",
    "description": "Table Creation_trial",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE Students\n",
        "comment": "The query to create a new table should start with 'CREATE TABLE' clause followed by the table name. The table name must not conflict with the name of one of the existing tables._\u00e7\u015f\u0131\u011f\u00fc\u00f6 "
      },
      {
        "line": "     (sid VARCHAR(20) NOT NULL,\n",
        "comment": "Column named sid, which is character domain type, has 20 digit space and does not allow NULL value. <br>In the body of the CREATE TABLE clause, the columns of the newly created table are defined. Firstly, every column in the table must have a unique name and domain name is to identify the kind of data that the column stores. Lastly, required data is to determine whether the column contains required data and prevents NULL values from appearing in the column; otherwise, NULL values are allowed.\n"
      },
      {
        "line": "      name VARCHAR(20),\n",
        "comment": "Each column definition is separated by comma. \n"
      },
      {
        "line": "      login VARCHAR(10),\n",
        "comment": "VARCHAR data type allows a column to store character strings varying in length from row to row. CHAR, another data type involving charater strings, is for columns holding fixed-length character string. \n"
      },
      {
        "line": "      age INTEGER DEFAULT NULL,\n",
        "comment": "'age' column is integer domain type and if user does not enter any value, the DBMS system automatically fill the tuple with NULL value by defining DEFAULT value as 'NULL'.\n"
      },
      {
        "line": "      gpa REAL DEFAULT 0.00);",
        "comment": " 'gpa' column defaults to 0.00 value. The 'CREATE TABLE' clause ends with closing parenthesis.<br><br>All SQL statements end with semicolon (;)."
      }
    ]
  },
  "TableCreation1_version_1_TR": {
    "name": "TableCreation_version_1_TR",
    "description": "Table Creation_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE Ogrenciler\n",
        "comment": "'CREATE TABLE' ifadesi, veri taban\u0131nda tablo olu\u015fturmak i\u00e7in kullan\u0131l\u0131r. Tabloya verilecek ad\u0131n (Ogrenciler) mevcut tablo adlar\u0131ndan biri ile \u00e7ak\u0131\u015fmamas\u0131 gerekmektedir."
      },
      {
        "line": "     (ogr_no VARCHAR(20) NOT NULL,\n",
        "comment": "'ogr_no' isimli s\u00fctun, 20 karakterlik alana sahiptir ve bu alanda NULL (bo\u015f) de\u011fere izin verilmemektedir. <br>'CREATE TABLE' ifadesinin g\u00f6vdesinde, yeni olu\u015fturulan tablonun s\u00fctunlar\u0131 tan\u0131mlan\u0131r.Tablodaki her bir s\u00fctun, benzersiz bir isime sahip olmal\u0131d\u0131r. Ayr\u0131ca s\u00fctunda yer alacak verilerin t\u00fcr\u00fcn\u00fc tan\u0131mlamal\u0131d\u0131r. Son olarak gerekli verinin k\u0131s\u0131tlama i\u00e7erip i\u00e7ermeyece\u011fi ve NULL de\u011fer i\u00e7erip i\u00e7ermeyece\u011fi belirlenir. Aksi takdirde NULL de\u011fere izin verilir."
      },
      {
        "line": "      isim VARCHAR(20),\n",
        "comment": "Her bir s\u00fctun tan\u0131m\u0131 virg\u00fcl (,) ile ayr\u0131l\u0131r."
      },
      {
        "line": "      kul_adi VARCHAR(10),\n",
        "comment": "Char ve Varchar, karakter  veri t\u00fcrlerini veritaban\u0131nda saklamak i\u00e7in kullan\u0131lmaktad\u0131r. Char veri tipi, tan\u0131mlanan kapasitenin tamam\u0131n\u0131 kullan\u0131r. Varchar veri tipi ise de\u011fi\u015fken bir yap\u0131ya sahiptir ve tan\u0131mlanan kapasiteye kadar olan boyutta de\u011fi\u015fkenlik g\u00f6sterebilir."
      },
      {
        "line": "      yas INTEGER DEFAULT NULL,\n",
        "comment": "'yas' s\u00fctunu integer (tamsay\u0131) veri tipinde tan\u0131mlanm\u0131\u015ft\u0131r. E\u011fer kullan\u0131c\u0131 herhangi bir de\u011fer girmezse veritaban\u0131 sistemi otomatik olarak NULL (bo\u015f) de\u011fer ile doldurur."
      },
      {
        "line": "      not_ort REAL DEFAULT 0.00);",
        "comment": "'not_ort' s\u00fctunun varsay\u0131lan de\u011feri (default) 0.00 olarak tan\u0131mlanm\u0131\u015ft\u0131r. 'Create Table' ifadesi kapal\u0131 parantez ile sonland\u0131r\u0131l\u0131r.<br><br>T\u00fcm SQL ifadelerinin sonuna noktal\u0131 virg\u00fcl (;) koyulur."
      }
    ]
  },
  "TableDrop1_version_1_TR": {
    "name": "TableDrop_version_1_TR",
    "description": "Table Drop_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "DROP TABLE Ogrenciler;\n",
        "comment": "DROP ifadesi ile 'Ogrenciler' ismindeki tablo ve bu tabloya ait t\u00fcm kay\u0131tlar silinir."
      }
    ]
  },
  "TableAlteration1_version_1_TR": {
    "name": "ColumnAddition_version_1_TR",
    "description": "Column Addition_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "ALTER TABLE Ogrenciler\n",
        "comment": "'ALTER TABLE' ifadesi ile var olan 'Ogrenciler' tablosuna 'ilk_yili' ad\u0131yla bir alan (s\u00fctun) eklenir."
      },
      {
        "line": "      ADD COLUMN baslangic_yili INTEGER;",
        "comment": "ALTER TABLE ifadesinin kullan\u0131m\u0131 yayg\u0131nd\u0131r. ALTER TABLE'de tan\u0131mlanan s\u00fctun CREATE TABLE komutu ile benzer \u015fekilde \u00e7al\u0131\u015f\u0131r."
      }
    ]
  },
  "TableAlteration2_version_1_TR": {
    "name": "ColumnDrop_version_1_TR",
    "description": "Column Drop_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "ALTER TABLE Ogrenciler\n",
        "comment": "ALTER TABLE ifadesi ile var olan bir tablodan bir ya da daha fazla s\u00fctun silinebilir. Bir s\u00fctun silindi\u011finde, veri b\u00fct\u00fcnl\u00fc\u011f\u00fcn\u00fc problemi ortaya \u00e7\u0131kabilir. \u00d6rne\u011fin; E\u011fer silinen s\u00fctun, baz\u0131 ili\u015fkilerde birincil anahtar olarak tan\u0131mlanm\u0131\u015fsa, silinen s\u00fctunun referans etti\u011fi yabanc\u0131 anahtar ge\u00e7ersiz olabilir."
      },
      {
        "line": "      DROP COLUMN yas;\n",
        "comment": "'yas' isimli s\u00fctun DROP COLUMN ifadesi kullan\u0131larak silinir.\n"
      }
    ]
  },
  "TableCreation2_version_1_TR": {
    "name": "PrimaryKey(1)_version_1_TR",
    "description": "Primary Key (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE Kay\u0131t\n",
        "comment": "Bu tabloda her bir \u00f6\u011frenci i\u00e7in kay\u0131t bilgileri yer almaktad\u0131r. Tabloda 'ogr_no', 'kurs_no', ve 'not' alanlar\u0131na yer verilmi\u015ftir."
      },
      {
        "line": "     (ogr_no CHAR(20),\n",
        "comment": "'ogr_no', \u00f6\u011frenci numaras\u0131d\u0131r ve 20 karakter uzunlu\u011funda veri girilebilir."
      },
      {
        "line": "      kurs_no CHAR(20),\n",
        "comment": "'kurs_no' kurs numaras\u0131d\u0131r ve 20 karakter uzunlu\u011funda veri girilebilir."
      },
      {
        "line": "      not CHAR(2),\n",
        "comment": "'not' her bir \u00f6\u011frencinin harf notudur ve 2 karakter uzunlu\u011funda veri girilebilir."
      },
      {
        "line": "      PRIMARY KEY (sid, cid));",
        "comment": "Bir \u00f6\u011frenci sadece bir kursa kaydolabilir ve ayn\u0131 kursa ikinci kez kaydolmas\u0131na izin verilmez. \u00d6\u011frenciler her bir kurs i\u00e7in sadece bir puana sahip olabilir. \u00c7\u00fcnk\u00fc birincil anahtar (primary key) hem 'ogr_no' hem de 'kurs_no' kullan\u0131larak belirlenmi\u015ftir. Bir tablonun birincil anahtar\u0131, tablodaki her bir sat\u0131r i\u00e7in benzersiz ve tek bir de\u011fer al\u0131r. "
      }
    ]
  },
  "TableCreation2_version_1_TR_true": {
    "name": "PrimaryKey(1)_version_1_TR",
    "description": "Primary Key (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE Kayit\n",
        "comment": "Bu tabloda her bir \u00f6\u011frenci i\u00e7in kay\u0131t bilgileri yer almaktad\u0131r. "
      },
      {
        "line": "     (ogr_no CHAR(20),\n",
        "comment": "'ogr_no', \u00f6\u011frencinin numaras\u0131d\u0131r ve 20 karakter uzunlu\u011funda veri girilebilir.\n"
      },
      {
        "line": "      kurs_no CHAR(20),\n",
        "comment": "'kurs_no' kurs numaras\u0131d\u0131r ve 20 karakter uzunlu\u011funda veri girilebilir."
      },
      {
        "line": "      not CHAR(2),\n",
        "comment": "'not' her bir \u00f6\u011frencinin harfli notudur ve 2 karakter uzunlu\u011funda veri girilebilir.\n"
      },
      {
        "line": "      PRIMARY KEY (ogr_no, kurs_no));",
        "comment": "Bir \u00f6\u011frenci sadece bir kursa kaydolabilir ve ayn\u0131 kursa ikinci kez kaydolmas\u0131na izin verilmez. \u00d6\u011frenciler her bir kurs i\u00e7in sadece bir puana sahip olabilir. \u00c7\u00fcnk\u00fc birincil anahtar (primary key) hem 'ogr_no' hem de 'kurs_no' kullan\u0131larak belirlenmi\u015ftir. Bir tablonun birincil anahtar\u0131, tablodaki her bir sat\u0131r i\u00e7in benzersiz ve tek bir de\u011fer al\u0131r. "
      }
    ]
  },
  "TableCreation3_version_1_TR": {
    "name": "PrimaryKeyandUniqueKey_version_1_TR",
    "description": "Primary Key and Unique Key_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE Kayit",
        "comment": "\u00d6\u011frenciler bir kursu sadece bir kez alabilirler."
      },
      {
        "line": " (kayit_no CHAR(20) NOT NULL,",
        "comment": "kayit_no birincil anahtar olarak tan\u0131mlanm\u0131\u015ft\u0131r. Dolay\u0131s\u0131yla bu de\u011fer  tablonun her bir sat\u0131r i\u00e7in benzersiz ve tek olmal\u0131d\u0131r."
      },
      {
        "line": "      ogr_no CHAR(20),\n",
        "comment": "ogr_no, alan\u0131 tan\u0131mlanm\u0131\u015ft\u0131r. Bu alan UNIQUE anahtar olarak tan\u0131mlanacakt\u0131r."
      },
      {
        "line": "      kurs_no CHAR(20),\n",
        "comment": "kurs_no, alan\u0131 tan\u0131mlanm\u0131\u015ft\u0131r. Bu alan UNIQUE anahtar olarak tan\u0131mlanacakt\u0131r."
      },
      {
        "line": "      PRIMARY KEY (kayit_no),\n",
        "comment": "E\u011fer birden fazla ayn\u0131 kayit_no olursa, veri b\u00fct\u00fcnl\u00fc\u011f\u00fc hatas\u0131 olur."
      },
      {
        "line": "      UNIQUE (ogr_no, kurs_no));\n",
        "comment": "UNIQUE anahtar olarak tan\u0131mlanan alan i\u00e7in bir de\u011fer sadece bir kere girilebilir. Bir ba\u015fka sat\u0131ra daha ayn\u0131 verinin girilmesine izin verilmez. Primary Key\u2019den farkl\u0131 olarak Unique Key, NULL (bo\u015fluk) de\u011ferini alabilir.  Bu \u00f6rnekte, kurs_no ve ogr_no \u00e7ifti, tek olmal\u0131d\u0131r.  UNIQUE anahtarlar\u0131, k\u0131s\u0131tl\u0131 nitelikler olarak tan\u0131mlamak m\u00fcmk\u00fcnd\u00fcr."
      }
    ]
  },
  "TableCreation9_version_1_TR": {
    "name": "PrimaryKey(2)_version_1_TR",
    "description": "Primary Key (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE kurs\n",
        "comment": "Bu \u00f6rnekte 'kurs' isimli bir tablo olu\u015fturulmaktad\u0131r. Kurs numaras\u0131 ve  kursun ad\u0131na ili\u015fkin bilgileri bu tabloda saklanmaktad\u0131r."
      },
      {
        "line": "     (kurs_no CHAR(20) NOT NULL PRIMARY KEY,\n",
        "comment": "Kurs numaras\u0131, 'kurs_no' olarak tan\u0131mlanmaktad\u0131r. Bu s\u00fctuna NULL (bo\u015f) b\u0131rak\u0131lmas\u0131na izin verilmemektedir. <BR><BR>Birincil anahtar, tablonun her bir sat\u0131r\u0131 i\u00e7in benzersiz tan\u0131mlanmaktad\u0131r. Bunun anlam\u0131 \u015fudur: ayn\u0131 kurs numaras\u0131na sahip birden fazla kurs olamaz. Ayr\u0131ca birincil anahtar olarak tan\u0131mlanan s\u00fctunun NULL (bo\u015f) de\u011fer almas\u0131na izin verilmez."
      },
      {
        "line": "      kurs_adi CHAR(40));\n",
        "comment": ""
      }
    ]
  },
  "testsql_portuguese": {
    "name": "testsql_portuguese",
    "description": "",
    "language": "sql",
    "author": "r.hosseini",
    "lines": [
      {
        "line": "select * from ent_activity;",
        "comment": "O hardware wireless rogue \u00e9 f\u00e1cil de introduzir. Os pontos de acesso wireless s\u00e3o\nrelativamente baratos e facilmente desdobrados. Uma equipe bem intencionada de\nconsultores trabalhando em uma sala de confer\u00eancia pode instalar um ponto de acesso\nwireless para compartilhar uma porta de conex\u00e3o individual na sala. Um hacker mal\nintencionado pode sentar numa cafeteria com um laptop wireless habilitado, efetuando a\nvarredura de um tr\u00e1fego n\u00e3o criptografado ou criptografado do WEP. Em ambos os\ncasos, s\u00e3o introduzidos riscos inaceit\u00e1veis. Indiferente se existir uma inten\u00e7\u00e3o maliciosa,\na introdu\u00e7\u00e3o do hardware nocivo pode comprometer a confidencialidade e integridade do\ntr\u00e1fego da rede. Os dispositivos wireless nocivos podem ser detectados fisicamente\nexaminando as instala\u00e7\u00f5es (conhecidas como \"a\u00e7\u00e3o de guerra\" (war driving), utilizando\nscanners de radiofreq\u00fc\u00eancia para determinar o local dos dispositivos wireless, ou\nutilizando-se sistemas projetados para analisar o tr\u00e1fego da rede para os dispositivos n\u00e3o\nautorizados."
      }
    ]
  },
  "TableCreation4_version_1_TR": {
    "name": "ForiegnKey_version_1_TR",
    "description": "Foriegn Key_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE Kayit\n",
        "comment": "Bu tablo \u00f6\u011frencilerin kay\u0131t bilgiler saklanmaktad\u0131r. Ayr\u0131ca 'O\u011frenciler' ad\u0131nda ayr\u0131 bir tablo vard\u0131r ve o tablonun birincil anahtar\u0131 'ogr_no'dur."
      },
      {
        "line": "     (ogr_no CHAR(20) NOT NULL,\n",
        "comment": "'ogr_no' \u00f6\u011frenci numaras\u0131d\u0131r. 'Kayit' tablosunun bir k\u0131sm\u0131 olarak tan\u0131mlanmadan \u00f6nce bu 'Ogrenciler' tablosunda tan\u0131mlanm\u0131\u015ft\u0131r."
      },
      {
        "line": "      kurs_no CHAR(20) NOT NULL,\n",
        "comment": ""
      },
      {
        "line": "      not CHAR(2),\n",
        "comment": ""
      },
      {
        "line": "      PRIMARY KEY (ogr_no, kurs_no),\n",
        "comment": "Belirli bir kurs ve \u00f6\u011frenci i\u00e7in tek bir de\u011fer vard\u0131r."
      },
      {
        "line": "      FOREIGN KEY (ogr_no)\n",
        "comment": "'Kayit' tablosundaki 'ogr_no', 'Ogrenciler' tablosuna referans eden yabanc\u0131 anahtard\u0131r. Yabanc\u0131 anahtar, mevcut tablo ile veri taban\u0131ndaki di\u011fer tablolar aras\u0131ndaki ili\u015fkinin tan\u0131mlanmas\u0131n\u0131 sa\u011flar."
      },
      {
        "line": "      REFERENCES Ogrenciler\n",
        "comment": "'ogr_no' yabanc\u0131 anahtar\u0131, 'Ogrenciler' tablosundan referans al\u0131nmaktad\u0131r. 'REFERENCES' anahtar kelimesinden sonra yabanc\u0131 anahtar\u0131n tan\u0131mland\u0131\u011f\u0131 tablo ismi yaz\u0131l\u0131r. 'REFERENCES' ifadesi ili\u015fkili tablolar\u0131 belirlemede \u00f6nemlidir. 'FOREIGN KEY' ve 'REFERENCES' anahtar kelimeleri virg\u00fcl ile ayr\u0131lmamal\u0131d\u0131r. E\u011fer ondan sonra sadece tablo ad\u0131 varsa veritaban\u0131 y\u00f6netim sistemi yabanc\u0131 anahtar olarak bu tablonun birincil anahtar\u0131n\u0131 alacakt\u0131r."
      },
      {
        "line": "      ON DELETE CASCADE\n",
        "comment": "E\u011fer bir ya da daha fazla yabanc\u0131 anahtar sat\u0131r\u0131 silinirse, yabanc\u0131 anahtardaki kayd\u0131n de\u011feri kaybolacakt\u0131r. Bu \u00f6rnekte, E\u011fer 'Ogrenciler' tablosundan \u00f6\u011frenci numaras\u0131 'ktl123' olan ki\u015fi,  silinirse, 'kayit' tablosundaki 'ktl123' kayd\u0131na ili\u015fkin bilgiye ula\u015f\u0131lamaz. \u00c7\u00fcnk\u00fc referans noktas\u0131 kaybolmu\u015ftur. 'kayit' tablosundan bir sat\u0131r silindi\u011finde, hi\u00e7bir zaman problem olmaz. E\u011fer bir kural a\u00e7\u0131k\u00e7a belirtilmemi\u015fse, veritaban\u0131 y\u00f6netim sistemi ba\u015flang\u0131\u00e7 de\u011feri olarak \u2018NO ACTION\u2019 kural\u0131n\u0131 uygular. Di\u011fer bir ifadeyle referans sat\u0131r silindi\u011finde, di\u011fer tablodaki ili\u015fkili sat\u0131rlara herhangi bir m\u00fcdahalede bulunulmaz. CASCADE silme kural\u0131 ile referans sat\u0131r silindi\u011finde, bununla ili\u015fkili t\u00fcm sat\u0131rlar yabanc\u0131 anahtardan otomatik olarak silinir."
      },
      {
        "line": "      ON UPDATE SET DEFAULT);",
        "comment": "E\u011fer yabanc\u0131 anahtar UPDATE ifadesi ile g\u00fcncellenecekse, yeni de\u011fer 'Ogrenciler' referans tablosunda e\u015fle\u015ftirilmelidir. SET DEFAULT ifadesi, referans tablosunda bir de\u011fer g\u00fcncellendi\u011finde kural\u0131 g\u00fcnceller. \u0130lgili t\u00fcm sat\u0131rlardaki yabanc\u0131 anahtar de\u011feri, default (ba\u015flang\u0131\u00e7) de\u011feri atan\u0131r. Bu kural, farkl\u0131 t\u00fcrdeki veritabanlar\u0131 i\u00e7in farkl\u0131l\u0131k g\u00f6sterebilir. Baz\u0131 veritabanlar\u0131ndan SET NULL olarak tan\u0131mlamak kesin kurald\u0131r."
      }
    ]
  },
  "TableCreation7_version_1_TR": {
    "name": "AssertionCreation(1)_version_1_TR",
    "description": "Assertion Creation (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE denizciler\n",
        "comment": "Bu \u00f6rnekte 'denizciler' ad\u0131nda bir tablo olu\u015fturulmu\u015ftur. Denizci eklemek i\u00e7in \u00f6ncelikle \u2018denizciler\u2019 ve \u2018tekneler\u2019 tablolar\u0131ndaki kay\u0131t say\u0131s\u0131n\u0131n toplam\u0131n\u0131n 100'\u00fc ge\u00e7ip ge\u00e7medi\u011fi kontrol edilmektedir. <br>**Bu \u00f6rnek sonraki \u00f6rnekle ili\u015fkidir."
      },
      {
        "line": "   (d_no INTEGER,\n",
        "comment": ""
      },
      {
        "line": "    d_adi CHAR(10),\n",
        "comment": ""
      },
      {
        "line": "    derece INTEGER,\n",
        "comment": ""
      },
      {
        "line": "    yas REAL,\n",
        "comment": ""
      },
      {
        "line": "    PRIMARY KEY (d_no),\n",
        "comment": ""
      },
      {
        "line": "    CHECK\n",
        "comment": "Bu \u00f6rnekte tekneler ve denizciler tablolar\u0131ndaki kay\u0131t say\u0131s\u0131n\u0131n toplam say\u0131s\u0131 100'den az olmal\u0131d\u0131r. Ancak bu \u00f6rnek YANLI\u015eTIR. Hem 'denizciler' hem de 'tekneler' isimli tablolar\u0131n kontrol k\u0131s\u0131tlamas\u0131,  'denizciler' tablosuna aittir. E\u011fer \u2018denizciler\u2019 tablosu bo\u015f ise tekneler tablosundaki kay\u0131t say\u0131s\u0131 herhangi bir \u015fey olabilir."
      },
      {
        "line": "    ((SELECT COUNT(D.d_no) \n",
        "comment": "Bu \u00f6rnek YANLI\u015eTIR. E\u011fer \u2018denizciler\u2019 tablosu bo\u015f ise tekneler tablosundaki kay\u0131t say\u0131s\u0131 herhangi bir \u015fey olabilir. Bu sorgu denizciler isimli tablodaki 'd_no' alan\u0131ndaki kay\u0131tlar\u0131n say\u0131s\u0131n\u0131 hesaplar. \u00d6ncelikle en i\u00e7teki sorgu y\u00fcr\u00fct\u00fcl\u00fcr."
      },
      {
        "line": "     FROM denizciler D) + \n",
        "comment": "\u0130ki ayr\u0131 sorgu toplama i\u015fareti kullan\u0131larak ba\u011flan\u0131r. Her iki sorgu sonu\u00e7lar\u0131, toplan\u0131r."
      },
      {
        "line": "    (SELECT COUNT(T.t_no) \n",
        "comment": "Bu sorgu, tekneler isimli tablodaki 't_no' alan\u0131ndaki kay\u0131tlar\u0131n say\u0131s\u0131n\u0131 hesaplar."
      },
      {
        "line": "     FROM tekneler T)\n",
        "comment": ""
      },
      {
        "line": "     < 100));\n",
        "comment": "\u0130ki alt sorgunun sonu\u00e7lar\u0131 toplam\u0131 100 ile kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r ve bu de\u011fer 100'den az ise \u015fart sa\u011flanm\u0131\u015ft\u0131r."
      }
    ]
  },
  "TableCreation8_version_1_TR": {
    "name": "AssertionCreation(2)_version_1_TR",
    "description": "Assertion Creation (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE ASSERTION dernek\n",
        "comment": "Bir \u00f6nceki \u00f6rnekte kendi i\u00e7erisinde de\u011ferlerin kontrol\u00fc ve uygunlu\u011fu kontrol edilmi\u015fti. Bu nedenle yanl\u0131\u015f bir \u00f6rnek oldu\u011fu ifade edilmi\u015ftir. \n\nASSERTION, bir veritaban\u0131 k\u0131s\u0131t\u0131d\u0131r. CHECK k\u0131s\u0131t\u0131 gibi ASSERTION arama \u015fart\u0131 olarak belirlenir. Ancak CHECK ile ASSERTION aras\u0131ndaki fark;  ASSERTION da arama \u015fart\u0131 \u00e7oklu tablolar\u0131n i\u00e7erikleri ve bunlar aras\u0131ndaki veri ili\u015fkilerini s\u0131n\u0131rland\u0131rabilir. \n"
      },
      {
        "line": "    CHECK\n",
        "comment": "\u2018ASSERTION\u2019 olu\u015fturmak i\u00e7in 'CHECK' anahtar kelimesini kullanmak zorunludur.\n"
      },
      {
        "line": "    ((SELECT COUNT(D.d_no) \n",
        "comment": "Bu \u00f6rnekte, hem tekneler hem de denizler tablolar\u0131, arama \u015fart\u0131n\u0131n ger\u00e7ekle\u015ftirilece\u011fi hedef tablolard\u0131r. Bu sorgu ile denizciler tablosunun \u2018d_no\u2019 alan\u0131ndaki mevcut kay\u0131t say\u0131s\u0131 hesaplan\u0131r."
      },
      {
        "line": "     FROM denizciler D) + \n",
        "comment": "\u0130ki sorgunun sonucunun toplam\u0131d\u0131r.\n"
      },
      {
        "line": "    (SELECT COUNT(T.t_no) \n",
        "comment": "Bu sorgu ile tekneler tablosunun \u2018t_no\u2019 alan\u0131ndaki mevcut kay\u0131tlar\u0131n say\u0131s\u0131 hesaplan\u0131r."
      },
      {
        "line": "     FROM tekneler T)\n",
        "comment": ""
      },
      {
        "line": "      < 100));\n",
        "comment": "Her iki sorgunun sonucunun toplam\u0131 100 ile kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r ve de\u011ferin 100'den k\u00fc\u00e7\u00fck olup olmad\u0131\u011f\u0131 kontrol edilir.\n"
      }
    ]
  },
  "TableCreation5_version_1_TR": {
    "name": "CheckConstraint(1)_version_1_TR",
    "description": "Check Constraint (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE Rezervasyonlar\n",
        "comment": "\u2018Rezervasyonlar' isimli tablo olu\u015fturulur. 'r_adi', 't_no' ve 'gun' isminde 3 s\u00fctunu vard\u0131r."
      },
      {
        "line": "    (r_adi CHAR(10),\n",
        "comment": "'r_adi' 10 karakterden olu\u015fan bir aland\u0131r."
      },
      {
        "line": "     t_no INTEGER,\n",
        "comment": "'t_no' integer t\u00fcr\u00fcnde veri giri\u015fi i\u00e7in tan\u0131mlanm\u0131\u015f bir aland\u0131r."
      },
      {
        "line": "     gun DATE,\n",
        "comment": "'gun' ise tarih t\u00fcr\u00fcnde veri giri\u015fi i\u00e7in tan\u0131mlanm\u0131\u015f bir aland\u0131r."
      },
      {
        "line": "     PRIMARY KEY(t_no, gun),\n",
        "comment": "Bir tekne g\u00fcnde bir kez ayr\u0131lm\u0131\u015f olmas\u0131 gerekir."
      },
      {
        "line": "     CONSTRAINT  YakamozRezYok\n",
        "comment": "CHECK s\u0131n\u0131rlamas\u0131 tan\u0131mlanmal\u0131d\u0131r. S\u0131n\u0131rlama tan\u0131mlanmas\u0131 yap\u0131lmadan \u00f6nce s\u0131n\u0131rland\u0131rma ismi belirlenmelidir. 'YakamozRezYok' CHECK s\u0131n\u0131rland\u0131rma ismidir."
      },
      {
        "line": "     CHECK\n",
        "comment": "CHECK s\u0131n\u0131rland\u0131rma, bir arama \u015fart\u0131d\u0131r. Bu do\u011fru/yanl\u0131\u015f(true/false) de\u011feri \u00fcretir. Bir s\u00fctun i\u00e7in kontrol s\u0131n\u0131rlamas\u0131 belirlendi\u011finde, veritaban\u0131 sistemi otomatik olarak her seferinde bu de\u011feri kontrol eder. Yeni bir sat\u0131r ekler ya da arama \u015fart\u0131n\u0131n sa\u011fland\u0131\u011f\u0131na ili\u015fkin sat\u0131r\u0131 g\u00fcnceller. S\u00fctun kontrol k\u0131s\u0131tlamas\u0131, CREATE TABLE ifadesi i\u00e7erisinde tan\u0131mlan\u0131r."
      },
      {
        "line": "      ('Yakamoz' <>\n",
        "comment": "Bu \u00f6rnekte, 'YakamozRezYok' ismi kontrol s\u0131n\u0131rlamas\u0131 olarak belirlenmi\u015ftir. Bir ki\u015fi 'Yakamoz'  i\u00e7in rezervasyon yapt\u0131rmak isterse  't_adi' yani tekne isminin bu olup olmad\u0131\u011f\u0131 kontrol edilir. 'Yakamoz' isimli teknenin rezervasyonu s\u0131n\u0131rland\u0131rmak i\u00e7indir.  "
      },
      {
        "line": "             (SELECT T.t_adi\n",
        "comment": "\u015eart olarak belirlenen alt sorgu 'Yakamoz' s\u00fctunu i\u00e7in kontrol edilmelidir. Bu alt sorgu, \u2018tekneler\u2019 tablosundan tekne ismini okumak i\u00e7indir."
      },
      {
        "line": "              FROM tekneler T\n",
        "comment": ""
      },
      {
        "line": "              WHERE T.t_no= t_no)));\n",
        "comment": "Teknenin numaras\u0131na (t_no) g\u00f6re \u2018tekneler\u2019 tablosunda tekne ismi okunur."
      }
    ]
  },
  "TableCreation6_version_1_TR": {
    "name": "CheckConstraint(2)_version_1_TR",
    "description": "Check Constraint (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE TABLE denizciler\n",
        "comment": "Bu \u00f6rnekte, 'denizciler' tablosu tan\u0131mlanmaktad\u0131r. \u2018d_no\u2019, \u2018d_adi\u2019, \u2018derece\u2019 ve \u2018yas\u2019 olmak \u00fczere 4 s\u00fctunu vard\u0131r."
      },
      {
        "line": "    (d_no INTEGER,\n",
        "comment": ""
      },
      {
        "line": "     d_adi CHAR(10),\n",
        "comment": ""
      },
      {
        "line": "     derece INTEGER,\n",
        "comment": ""
      },
      {
        "line": "     yas REAL,\n",
        "comment": ""
      },
      {
        "line": "     PRIMARY KEY (d_no),\n",
        "comment": ""
      },
      {
        "line": "     CHECK (derece>= 1 AND derece<= 10));\n",
        "comment": "'derece' alan\u0131n de\u011feri 1 ile 10 aras\u0131ndaki de\u011ferlerle s\u0131n\u0131rland\u0131r\u0131lm\u0131\u015ft\u0131r. Check s\u0131n\u0131rland\u0131rmas\u0131 eklenmi\u015f bir alana yeni bilgi eklenirken veya bilgi g\u00fcncellenirken, veri yaz\u0131lm\u0131\u015f olan kurallara g\u00f6re kontrol edilir ve kurala uymuyorsa bir hata verilir ve veri kaydedilmez."
      }
    ]
  },
  "DataInsertion1_version_1_TR": {
    "name": "InsertingData(1)_version_1_TR",
    "description": "Inserting Data (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "INSERT INTO Ogrenciler(ogr_no, isim, yas)\n",
        "comment": "\u2018Ceren\u2019 22 ya\u015f\u0131nda bir \u00f6\u011frencidir ve \u00f6\u011frenci numaras\u0131 '2007001' olacak \u015fekilde 'Ogrenciler' tablosuna eklenmektedir."
      },
      {
        "line": "      VALUES('2007001', 'Ceren', 22);\n",
        "comment": "VALUES ifadesi, eklenecek de\u011ferleri tan\u0131mlar. De\u011ferlerin s\u0131ras\u0131, s\u00fctun/alan ad\u0131 s\u0131ras\u0131na g\u00f6re olmal\u0131d\u0131r. E\u011fer bir alan\u0131n veri t\u00fcr\u00fc metinsel ifadelerden olu\u015facak \u015fekilde tan\u0131mlanm\u0131\u015fsa, bu alanlara eklenecek de\u011ferler tek yada \u00e7ift t\u0131rnak i\u00e7ersinde yaz\u0131lmal\u0131d\u0131r. 'ogr_no' ve 'isim' alanlar\u0131 karakterlerden olu\u015fan metinsel ifade olarak tan\u0131mlanm\u0131\u015ft\u0131r. Bu nedenle bu alanlara eklenecek de\u011ferler tek t\u0131rnak i\u00e7erisinde yaz\u0131lm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataInsertion2_version_1_TR": {
    "name": "InsertingData(2)_version_1_TR",
    "description": "Inserting Data (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "INSERT INTO Ogrenciler(ogr_no, isim, kul_adi, yas, not_ort)\n",
        "comment": "\u2018INSERT' deyimi, 'INTO' deyimiyle birlikte kullan\u0131lmak zorundad\u0131r. Eklenecek verilerin s\u0131ras\u0131, SQL ifadesindeki her bir s\u00fctunun s\u0131ras\u0131 ile e\u015fle\u015fmelidir. E\u011fer s\u00fctun isimleri belirtilmezse, tablodaki s\u00fctun s\u0131ras\u0131na g\u00f6re veriler eklenir."
      },
      {
        "line": "      VALUES('53688', 'Yaren', 'yaren@edu.tr', 18, 3.2);",
        "comment": "VALUES' anahtar kelimesi, eklenecek veriyi tan\u0131mlamak i\u00e7in gereklidir. Ogr_no, isim veya kul_adi alanlar\u0131 karakterlerden olu\u015fan metinsel veri t\u00fcr\u00fcnde tan\u0131mland\u0131\u011f\u0131ndan, eklenecek de\u011ferler tek t\u0131rnak i\u00e7erisinde sunulmu\u015ftur."
      }
    ]
  },
  "DataInsertion3_version_1_TR": {
    "name": "InsertingData(3)_version_1_TR",
    "description": "Inserting Data (3)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "INSERT INTO hesap\n",
        "comment": "Bu \u00f6rnekte, 'Yenimahalle' \u015fubesinin t\u00fcm bor\u00e7lu m\u00fc\u015fteriler i\u00e7in 200TL tasarruf hesab\u0131 olu\u015fturulacakt\u0131r. Kullan\u0131c\u0131 taraf\u0131ndan girilen veriden ziyade bu sorguda di\u011fer tablodan okunan veriler eklenecektir. 'hesap' tablosu, 'hesap_no', 'sube_adi' ve 'bakiye' olarak tan\u0131mlanm\u0131\u015ft\u0131r. Bu s\u0131rada veriler depolanmaktad\u0131r."
      },
      {
        "line": "      SELECT borc_no, sube_adi, 200\n",
        "comment": "Ekleme yapmadan \u00f6nce 'SELECT' komutu \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r. 'borc' tablosundan, 'borc_no've 'sube_adi' alanlar\u0131ndaki veriler se\u00e7ilir ve 'hesap' tablosundaki 'bakiye' isimli son s\u00fctuna 200TL tan\u0131mlan\u0131r. B\u00f6ylece se\u00e7ilen t\u00fcm hesaplara, 200TL de\u011ferindeki para eklenmi\u015f olur."
      },
      {
        "line": "          FROM borc\n",
        "comment": ""
      },
      {
        "line": "          WHERE sube_adi= 'Yenimahalle';\n",
        "comment": "Burada \u015fart, 'Yenimahalle' \u015fubesi ile s\u0131n\u0131rland\u0131r\u0131lm\u0131\u015ft\u0131r. 'sube_adi' karakterlerden olu\u015fan metinsel bir alan olarak tan\u0131mland\u0131\u011f\u0131 i\u00e7in ilgili de\u011fer tek t\u0131rnak i\u00e7erisinde yaz\u0131lm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataInsertion4_version_1_TR": {
    "name": "InsertingData(4)_version_1_TR",
    "description": "Inserting Data (4)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "INSERT INTO Para_Yatiranlar\n",
        "comment": "'Para_Yatiranlar' tablosuna veri eklenmektedir."
      },
      {
        "line": "      SELECT musteri_adi, borc_no\n",
        "comment": "'Yenimahalle' \u015fubesindeki m\u00fc\u015fterilerin hesaplar\u0131n\u0131 de\u011ferlendirmek i\u00e7in 'borc_alanlar' tablosunda 'musteri_adi' ve 'borc' tablosundan 'borc_no' se\u00e7ilir. 'Para_Yatiranlar' tablosunda saklanan veri, bu iki veridir."
      },
      {
        "line": "           FROM borc, borc_alanlar\n",
        "comment": "'musteri_adi', 'borc_alanlar' tablosundan, 'borc_no' ise 'borc' tablosundan gelmektedir."
      },
      {
        "line": "           WHERE sube_adi ='Yenimahalle'\n",
        "comment": "'Yenimahalle' \u015fubesinden m\u00fc\u015fteriler se\u00e7mek i\u00e7in bu \u015fart yaz\u0131lm\u0131\u015ft\u0131r."
      },
      {
        "line": "              AND borc.hesap_no= borc_alanlar.hesap_no;",
        "comment": "Her bir bor\u00e7 alan m\u00fc\u015fterinin borcu kal\u0131p kalmad\u0131\u011f\u0131 kontrol edilir. "
      }
    ]
  },
  "DataDeletion1_version_1_TR": {
    "name": "DeletingData_version_1_TR",
    "description": "Deleting Data_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "DELETE\n",
        "comment": "DELETE ifadesi, bir ya da daha fazla veri sat\u0131r\u0131n\u0131n silinmesini sa\u011flar. 'DELETE' anahtar kelimesi SQL t\u00fcr\u00fcne g\u00f6re tan\u0131mlan\u0131r ve 'from' deyimi hedef tabloyu belirtmek i\u00e7in zorunlu olarak kullan\u0131lmaktad\u0131r."
      },
      {
        "line": "      FROM Ogrenciler;\n",
        "comment": "'Ogrenciler' tablosundan t\u00fcm sat\u0131rlar silinir.\n"
      }
    ]
  },
  "DataDeletion2_version_1_TR": {
    "name": "DeletingwithCondition(1)_version_1_TR",
    "description": "Deleting with Condition (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "DELETE FROM hesap\n",
        "comment": "'hesap' isimli tablo, hedef tablo olarak belirlenmi\u015ftir."
      },
      {
        "line": "     WHERE sube_adi  IN\n",
        "comment": "IN \u00fcyelik testidir. Bu, hedef de\u011ferler listesinin, veri de\u011feri ile e\u015fle\u015fip e\u015fle\u015fmedi\u011fini test eder. Bu sat\u0131rda IN, alt sorgu sonu\u00e7lar\u0131 olan Trabzon\u2019daki \u015fubeler ile  hesap tablosundaki \u015fube isimlerinin kar\u015f\u0131la\u015ft\u0131rmas\u0131 yap\u0131l\u0131r."
      },
      {
        "line": "         (SELECT sube_adi  \n",
        "comment": "Bu \u00f6rnekte, 'Trabzon' da bulunan \u015fubeleri bulmak i\u00e7in alt sorgu kullan\u0131lmaktad\u0131r ve elde edilen sonu\u00e7lar listesi, hesap tablosundaki \u015fube isimleri ile kar\u015f\u0131la\u015ft\u0131r\u0131lmaktad\u0131r. "
      },
      {
        "line": "          FROM sube\n",
        "comment": ""
      },
      {
        "line": "          WHERE sube_sehri= 'Trabzon');\n",
        "comment": "WHERE ko\u015fulu ile belirli veri sat\u0131rlar\u0131 se\u00e7ilmektedir. Bu \u00f6rnekte \u015fube \u015fehri olarak 'Trabzon' sat\u0131rlar\u0131 se\u00e7ilmi\u015ftir. 'sube_sehri' s\u00fctunu metin t\u00fcr\u00fcnde tan\u0131mland\u0131\u011f\u0131ndan kar\u015f\u0131la\u015ft\u0131rma yapmak i\u00e7in test de\u011feri de benzer veri t\u00fcr\u00fcnde olmal\u0131d\u0131r. Bu nedenle 'Trabzon' ifadesi tek t\u0131rnak i\u00e7erisinde yaz\u0131lm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataDeletion3_version_1_TR": {
    "name": "DeletingwithCondition(2)_version_1_TR",
    "description": "Deleting with Condition (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "DELETE FROM hesap\n",
        "comment": "Hedef tablo 'hesap' isimli tablodur.\n"
      },
      {
        "line": "     WHERE bakiye < \n",
        "comment": "\nBu sorgunun \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131nda \u00f6ncelikle, t\u00fcm hesab\u0131n ortalama miktar\u0131n\u0131 hesaplamak i\u00e7in alt sorgu \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r ve daha sonra her hesap bakiyesi bu ortalama ile kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r. Son olarak ortalamadan d\u00fc\u015f\u00fck olan hesaplar silinir. \n"
      },
      {
        "line": "         (SELECT AVG(bakiye)\n",
        "comment": "Bu alt sorgu her bir hesab\u0131n bakiyesinin, ortalamas\u0131n\u0131 hesaplamak i\u00e7indir."
      },
      {
        "line": "          FROM hesap);\n",
        "comment": ""
      }
    ]
  },
  "DataUpdate3_version_1_TR": {
    "name": "UpdatingData(1)_version_1_TR",
    "description": "Updating Data (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "UPDATE Satis_orani\n",
        "comment": "E\u011fer belirli bir s\u00fctunda t\u00fcm veriler g\u00fcncellenmek istenirse WHERE ifadesi kullan\u0131lmas\u0131na gerek yoktur. Bu \u00f6rnekte, sat\u0131\u015f temsilcilerinin t\u00fcm kota verileri %5 artt\u0131r\u0131lm\u0131\u015ft\u0131r."
      },
      {
        "line": "     SET kota = 1.05 * kota;\n",
        "comment": "T\u00fcm sat\u0131\u015f temsilcilerinin kotalar\u0131na %5 eklenmi\u015ftir."
      }
    ]
  },
  "DataUpdate1_version_1_TR": {
    "name": "UpdatingData(2)_version_1_TR",
    "description": "Updating Data (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "UPDATE Ogrenciler O\n",
        "comment": "UPDATE anahtar kelimesinden sonra, tablo ad\u0131 yaz\u0131l\u0131r. Bu \u00f6rnekte tablo ad\u0131 'Ogrenciler'  olarak tan\u0131mlanm\u0131\u015ft\u0131r. Ancak tablo ad\u0131 'O' olarak yeniden isimlendirilmi\u015ftir \u00e7\u00fcnk\u00fc esas tablo ad\u0131 biraz uzundur. Bu t\u00fcr k\u0131saltmalar 'alias' olarak isimlendirilmektedir. "
      },
      {
        "line": "     SET O.not_ort = O.not_ort*1.01\n",
        "comment": "UPDATE ifadesinde SET kullanmak zorunludur ve g\u00fcncellenecek alanlar\u0131n/sutunlar\u0131n belirtilmesi gerekir. Alanlar belirtilirken tabloya yeni verilen k\u0131saltma isim ile nokta (.) i\u015fareti kullan\u0131l\u0131r. Bu \u00f6rnekte tablo ismi, 'O' olarak yeniden isimlendirildi\u011fi i\u00e7in 'not_ort' alan\u0131 \u00f6rnekteki gibi yaz\u0131lmal\u0131d\u0131r. \u015eart\u0131 sa\u011flayan her bir kayd\u0131n 'not_ort' de\u011feri 1.01 ile \u00e7arp\u0131l\u0131r ve yeni de\u011fer ilgili alana kaydedilir."
      },
      {
        "line": "     WHERE O.not_ort >= 3.3;\n",
        "comment": "T\u00fcm kay\u0131tlar g\u00fcncellenmez sadece not ortalamas\u0131 3.3\u2019e e\u015fit ve daha y\u00fcksek olanlar se\u00e7ilir."
      }
    ]
  },
  "DataUpdate2_version_1_TR": {
    "name": "UpdatingData(3)_version_1_TR",
    "description": "Updating Data (3)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "UPDATE Ogrenciler O",
        "comment": "UPDATE ifadesi tablonun se\u00e7ilen sat\u0131rlar\u0131nda bir ya da daha fazla s\u00fctunda de\u011ferlerin g\u00fcncellenmesini sa\u011flar."
      },
      {
        "line": "     SET O.yas = O.yas+1 AND O.yas = O.yas-1\n",
        "comment": "SET ifadesinden sonra g\u00fcncellenecek yeni de\u011ferler yaz\u0131lmal\u0131d\u0131r."
      },
      {
        "line": "     WHERE O.ogr_no = 5368;\n",
        "comment": "Tan\u0131mlanan \u015fart\u0131n sa\u011flan\u0131p sa\u011flanmad\u0131\u011f\u0131 kontrol edilir ve \u015fart\u0131 sa\u011flayan t\u00fcm sat\u0131r/larda g\u00fcncelleme i\u015flemi ger\u00e7ekle\u015ftirilir. "
      }
    ]
  },
  "DataUpdate4_version_1_TR": {
    "name": "Updatingwithcondition_version_1_TR",
    "description": "Updating with condition_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "UPDATE Musteriler",
        "comment": "Bu \u00f6rnekte birden fazla \u015fart tek bir SQL ifadesinde tan\u0131mlanm\u0131\u015ft\u0131r."
      },
      {
        "line": "     SET mus_no = 102\n",
        "comment": ""
      },
      {
        "line": "     WHERE mus_no IN (105, 106, 107);\n",
        "comment": "IN \u00fcyelik testidir. Bu testle hedef de\u011ferlerin herhangi biri ile veri de\u011ferinin e\u015fle\u015fip e\u015fle\u015fmedi\u011fi test edilir. Bu \u00f6rnekte, m\u00fc\u015fteri numaras\u0131 (mus_no) 105, 106 ya da 107 de\u011ferine e\u015fit olan m\u00fc\u015fteriler belirlenmeye \u00e7al\u0131\u015f\u0131lm\u0131\u015f ve bu m\u00fc\u015fterilerin numaras\u0131 102 olarak g\u00fcncellenmi\u015ftir."
      }
    ]
  },
  "DataUpdate5_version_1_TR": {
    "name": "Updatingwithsubquery_version_1_TR",
    "description": "Updating with subquery_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "UPDATE Musteriler\n",
        "comment": ""
      },
      {
        "line": "     SET kredi_limiti = kredi_limiti + 5000.00\n",
        "comment": "G\u00fcncelleme yap\u0131lmadan \u00f6nce parantez i\u00e7indeki alt sorgu, veriyi s\u0131n\u0131rland\u0131rmak i\u00e7in \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r. Ard\u0131ndan \u015fart\u0131 sa\u011flayan kayd\u0131n/kay\u0131tlar\u0131n mevcut kredi limitlerine 5000 eklenerek g\u00fcncelleme yap\u0131l\u0131r."
      },
      {
        "line": "     WHERE mus_no IN\n",
        "comment": "WHERE deyimi ile alt sorgu sonucunda elde edilen m\u00fc\u015fteri numaras\u0131na/numaralar\u0131na (mus_no) g\u00f6re g\u00fcncelleme yap\u0131lacak olan kay\u0131t/kay\u0131tlar belirlenir."
      },
      {
        "line": "          (SELECT DISTINCT mus\n",
        "comment": "SELECT sorgusu alt sorgudur. Bu sorgu 25000 \u00fczerinde \u00fcr\u00fcn sipari\u015f eden m\u00fc\u015fterilerin listesini elde etmek i\u00e7in kullan\u0131lm\u0131\u015ft\u0131r. Topluca baz\u0131 veriler se\u00e7ilmek istendi\u011finde bu sorguyu kullanmak gerekir."
      },
      {
        "line": "           FROM siparisler\n",
        "comment": ""
      },
      {
        "line": "           WHERE miktar> 25000.00);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection1_version_1_TR": {
    "name": "SelectingOneAttribute_version_1_TR",
    "description": "Selecting One Attribute_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT ogr_no\n",
        "comment": "SELECT ifadesi, FROM ile birlikte kullan\u0131l\u0131r. SELECT FROM ifadesi, tablodaki s\u00fctun/s\u00fctunlardan veri \u00e7ekmek i\u00e7in kullan\u0131l\u0131r. Veri \u00e7ekilecek alan isimleri virg\u00fcl ile birbirinden ayr\u0131larak yaz\u0131l\u0131r. Bu \u00f6rnekte sadece 'ogr_no' alan\u0131 se\u00e7ilmi\u015ftir. Bu nedenle virg\u00fcl kullan\u0131lmas\u0131na gerek yoktur."
      },
      {
        "line": "      FROM Ogrenciler;",
        "comment": "FROM ifadesi ile sorgulanan tablodan elde edilen kay\u0131tlar\u0131n listelenmesi sa\u011flan\u0131r. Bir ya da daha fazla veri tablodan \u00e7ekilebilir."
      }
    ]
  },
  "DataSelection2_version_1_TR": {
    "name": "SelectingMultipleAttributes_version_1_TR",
    "description": "Selecting Multiple Attributes_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT isim, kul_adi\n",
        "comment": "SELECT ifadesinden sonra se\u00e7ilmek istenen alanlar yaz\u0131l\u0131r. E\u011fer birden fazla alan se\u00e7ilmek isteniyorsa bu alanlar virg\u00fcl ile ayr\u0131l\u0131r. Bu \u00f6rnekte; 'isim' ve 'kul_adi' alanlar\u0131 'Ogrenciler' tablosundan se\u00e7ilmi\u015ftir."
      },
      {
        "line": "      FROM Ogrenciler;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection3_version_1_TR": {
    "name": "SelectingAllAttributes_version_1_TR",
    "description": "Selecting All Attributes_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT * \n",
        "comment": "SELECT'den sonra kullan\u0131lan y\u0131ld\u0131z (*) ifadesi tabloda bulunan b\u00fct\u00fcn alanlar\u0131n se\u00e7ilmesini sa\u011flar."
      },
      {
        "line": "      FROM Ogrenciler;",
        "comment": "FROM ifadesi hedef tabloyu tan\u0131mlamak i\u00e7in kullan\u0131l\u0131r."
      }
    ]
  },
  "DataSelection4_version_1_TR": {
    "name": "SkippingDuplicates_version_1_TR",
    "description": "Skipping Duplicates_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT DISTINCT isim\n",
        "comment": "DISTINCT anahtar kelimesi, SELECT  ile ger\u00e7ekle\u015ftirilen sorgu sonu\u00e7lar\u0131ndan tekrar eden kay\u0131tlar\u0131n silinmesini sa\u011flar. E\u011fer DISTINCT kelimesi yaz\u0131lmazsa SQL tekrar eden kay\u0131tlar\u0131 elemine etmez."
      },
      {
        "line": "      FROM Ogrenciler;",
        "comment": ""
      }
    ]
  },
  "DataSelection12_version_1_TR": {
    "name": "ArithmeticExpression_version_1_TR",
    "description": "Arithmetic Expression_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT borc_no, sube_adi, miktar* 100\n",
        "comment": "Do\u011frudan s\u00fctun de\u011ferleri \u00fczerinde  * , + , - , /  gibi aritmetik i\u015flemler yap\u0131labilir. \u0130lgili de\u011feri yeniden hesaplamak m\u00fcmk\u00fcnd\u00fcr. Ancak veritaban\u0131nda saklanan de\u011fer de\u011fi\u015fmez."
      },
      {
        "line": "     FROM borc;",
        "comment": ""
      }
    ]
  },
  "DataSelection6_version_1_TR": {
    "name": "SelectionCondition_version_1_TR",
    "description": "Selection Condition_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT \u0130sim, Kota, Satislar\n",
        "comment": "Bu sorgu 'Satis_Personeli' tablosundan 3 alan\u0131n (\u0130sim, Kota, Satislar) se\u00e7ilmesini sa\u011flar. "
      },
      {
        "line": "      FROM Satis_Personeli\n",
        "comment": ""
      },
      {
        "line": "      WHERE sicil_no = 107;",
        "comment": "\u00d6zellikle bu sorgu,sicil numaras\u0131 107 olan ki\u015fiyle ilgili veri sat\u0131r\u0131n\u0131n tablodan \u00e7ekilmesini sa\u011flar. WHERE ifadesi, almak istedi\u011finiz sat\u0131rlar\u0131 s\u0131n\u0131rlamak i\u00e7in kullan\u0131l\u0131r. WHERE ifadesinden sonra aranacak olan \u015fart yaz\u0131l\u0131r. Arama \u015fart\u0131 \u00fc\u00e7 sonu\u00e7tan birini \u00fcretebilir.  E\u011fer \u015fart sa\u011fland\u0131ysa, sat\u0131r sorgu sonu\u00e7lar\u0131nda yer almaktad\u0131r. E\u011fer \u015fart sa\u011flanmad\u0131ysa, sat\u0131r sorgu sonu\u00e7lar\u0131ndan \u00e7\u0131kar\u0131lmaktad\u0131r. E\u011fer arama \u015fart\u0131 NULL bir de\u011fer ise sat\u0131r sorgu sonu\u00e7lar\u0131ndan \u00e7\u0131kar\u0131lmaktad\u0131r.  Asl\u0131nda arama \u015fart\u0131, tablonun sat\u0131rlar\u0131nda bir filtreleme i\u015flevi g\u00f6r\u00fcr. \u015eart\u0131 sa\u011flayan sat\u0131rlar filtreden ge\u00e7er ve sorgulama sonu\u00e7lar\u0131n\u0131n bir par\u00e7as\u0131 olur."
      }
    ]
  },
  "DataSelection7_version_1_TR": {
    "name": "ComparisonCondition(1)_version_1_TR",
    "description": "Comparison Condition (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT * \n",
        "comment": "'Ogrenciler' tablosundaki t\u00fcm alanlar\u0131 bulmak i\u00e7in bu sorgu kullan\u0131l\u0131r."
      },
      {
        "line": "      FROM Ogrenciler \n",
        "comment": ""
      },
      {
        "line": "      WHERE not_ort> 3.2;\n",
        "comment": "WHERE \u015fart\u0131 ile not ortalamas\u0131 3.2'den b\u00fcy\u00fck olan \u00f6\u011frenciler ile sonu\u00e7lar s\u0131n\u0131rland\u0131r\u0131l\u0131r. "
      }
    ]
  },
  "DataSelection8_version_1_TR": {
    "name": "ComparisonCondition(2)_version_1_TR",
    "description": "Comparison Condition (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT Sehir, Satislar, Hedef\n",
        "comment": "'Bayiler' tablosundan hedef miktar, sat\u0131\u015f miktar\u0131 ve \u015fehirler se\u00e7ilmi\u015ftir."
      },
      {
        "line": "      FROM Bayiler\n",
        "comment": ""
      },
      {
        "line": "      WHERE Satislar< (.8 * Satislar);\n",
        "comment": "Bu sorgu ile hedef miktar\u0131n %80'ninden az olan sat\u0131\u015flar bulunur. Bu \u015fart\u0131 i\u015fletmek i\u00e7in SQL, (.8 * hedef) ifadesinin de\u011ferini i\u00e7eren ge\u00e7ici bir alan olu\u015fturur. 'hedef', 'bayiler' tablosundaki bir aland\u0131r ve 'satislar' alan\u0131ndaki de\u011fer ile ge\u00e7ici olarak \u00fcretilen alandaki de\u011fer kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r."
      }
    ]
  },
  "DataSelection9_version_1_TR": {
    "name": "ComparisonCondition(3)_version_1_TR",
    "description": "Comparison Condition (3)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT Sehir, Yonetici\n",
        "comment": "Bu sorgu, 'Bayiler' tablosundaki y\u00f6netici isimleri ve \u015fehirleri listeler."
      },
      {
        "line": "      FROM Bayiler\n",
        "comment": ""
      },
      {
        "line": "      WHERE Yonetici <> 108;\n",
        "comment": "<> ifadesi e\u015fitsizli\u011fi test etmektedir. Bu \u015fart, numaras\u0131 108 olmayan y\u00f6neticiyi bulmak i\u00e7indir."
      }
    ]
  },
  "DataSelecton11_version_1_TR": {
    "name": "MultipleComparisons(1)_version_1_TR",
    "description": "Multiple Comparisons (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT borc_no\n",
        "comment": ""
      },
      {
        "line": "      FROM borc\n",
        "comment": ""
      },
      {
        "line": "      WHERE sube_adi = 'Yenimahalle' AND miktar > 1200;",
        "comment": "Ko\u015fullarda birden fazla kar\u015f\u0131la\u015ft\u0131rma yapabilmek i\u00e7in AND, OR ya da NOT  gibi mant\u0131ksal ba\u011flay\u0131c\u0131lar kullan\u0131labilir. Bu \u00f6rnekte, hem \u015fube ad\u0131 'Yenimahalle' olan hem de miktar\u0131 1200'den fazla olan bor\u00e7lu ki\u015filer 'borc' tablosundan sorgulanmaktad\u0131r. "
      }
    ]
  },
  "DataSelection13_version_1_TR": {
    "name": "MultipleComparisons(2)_version_1_TR",
    "description": "Multiple Comparisons (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT mus_no, borc_alanlar.borc_no, miktar\n",
        "comment": "Bu sorguda 'borc_no' alan\u0131 iki farkl\u0131 tabloda (borc_alanlar ve borc) ayn\u0131 isimle yer ald\u0131\u011f\u0131ndan dolay\u0131 \u015fart\u0131 yazarken tablo ismi yaz\u0131ld\u0131ktan sonra nokta koyularak alan ad\u0131 (borc_no) yaz\u0131l\u0131r. "
      },
      {
        "line": "     FROM borc_alanlar, borc\n",
        "comment": "\u0130ki tablodan (borc_alanlar, borc) veriler \u00e7ekilir."
      },
      {
        "line": "     WHERE borc_alanlar.borc_no = borc.borc_no AND sube_adi = 'Yenimahalle';\n",
        "comment": "'borc_alanlar' tablosundaki 'borc_no' ile 'borc' tablosundaki 'borc_no' alan\u0131ndaki verilerin e\u015fitli\u011fi test edilir. Ayr\u0131ca \u015fube ad\u0131 'Yenimahalle' olup olmad\u0131\u011f\u0131 kontrol edilir.Bu iki \u015fart\u0131 da sa\u011flayan veri \u00e7ekilir. \u00c7\u00fcnk\u00fc 'AND' mant\u0131ksal operat\u00f6r\u00fc kullan\u0131lm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataSelection14_version_1_TR": {
    "name": "RangeTest(1)_version_1_TR",
    "description": "Range Test (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT borc_no\n",
        "comment": ""
      },
      {
        "line": "     FROM borc\n",
        "comment": ""
      },
      {
        "line": "     WHERE miktar BETWEEN 2000 AND 100000;\n",
        "comment": "BETWEEN ifadesi belirli bir aral\u0131\u011f\u0131 test eden operat\u00f6rd\u00fcr. Verinin belirlenen iki de\u011fer aras\u0131nda olup olmad\u0131\u011f\u0131n\u0131 kontrol eder. Test edilecek aral\u0131k i\u00e7in,  AND anahtar kelimesinin sol k\u0131sm\u0131na alt de\u011fer, sa\u011f k\u0131sm\u0131na ise \u00fcst de\u011fer yaz\u0131l\u0131r. Bu (miktar >= 2000) AND (miktar <=100000) ifadesi ile ayn\u0131d\u0131r."
      }
    ]
  },
  "DataSelection15_version_1_TR": {
    "name": "RangeTest(2)_version_1_TR",
    "description": "Range Test (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT siparis_no, tarih, urun, miktar\n",
        "comment": ""
      },
      {
        "line": "     FROM siparisler\n",
        "comment": ""
      },
      {
        "line": "     WHERE tarih BETWEEN '20-Mart-16' AND '23-Nisan-16';\n",
        "comment": "Aral\u0131k testi, tarih veri t\u00fcr\u00fc i\u00e7inde yap\u0131labilir. \u0130ki tarih aras\u0131ndaki verileri \u00e7ekmek i\u00e7in bu sorgu kullan\u0131labilir.  Bu ifade ayn\u0131 zamanda  tarih >= '20-Mart-16') AND (tarih <= '23-Nisan-16') ile ayn\u0131d\u0131r."
      }
    ]
  },
  "DataSelection17_version_1_TR": {
    "name": "StringOperation_version_1_TR",
    "description": "String Operation_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT kelime_gruplari\n",
        "comment": ""
      },
      {
        "line": "     FROM kelimeler",
        "comment": ""
      },
      {
        "line": "     WHERE metinler LIKE '%spor%';",
        "comment": "'Like' operat\u00f6r\u00fc ile B\u0130R S\u00dcTUNUN DE\u011eER\u0130N\u0130 TAM OLARAK DE\u011e\u0130L, SADECE B\u0130R KISMINI BEL\u0130RTEREK ARAMA YAPILAB\u0130L\u0130R. 'Like' operat\u00f6r\u00fc ile birlikte farkl\u0131 ama\u00e7lar i\u00e7in joker karakterler kullan\u0131l\u0131r. Bunlar :\n '%' karakteri bir ya da daha fazla karakter yerine kullan\u0131l\u0131r.\n '_' karakteri ise tek karakter yerine kullan\u0131l\u0131r.\n\nBu sorguda, i\u00e7erisinde 'spor' ifadesi ge\u00e7en kay\u0131tlar se\u00e7ilmektedir. Buna g\u00f6re a\u015fa\u011f\u0131daki sonu\u00e7lar olas\u0131d\u0131r:\nTrabzonspor, Spor merkezi, Sporcu."
      }
    ]
  },
  "DataSelection10_version_1_TR": {
    "name": "MultipleTableSelection(1)_version_1_TR",
    "description": "Multiple Table Selection (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT O.isim, K.kurs_no \n",
        "comment": "Bu \u00f6rnekte \u00f6\u011frenci ismi ve kurs numaras\u0131 alanlar\u0131ndan veri \u00e7ekilmek istenmektedir.\n"
      },
      {
        "line": "      FROM Ogrenciler O, Kayit K\n",
        "comment": "FROM ifadesinden sonra sorgu sonu\u00e7lar\u0131na katk\u0131 sa\u011flayacak olan t\u00fcm tablolar belirtilir. Bu SQL \u00f6rne\u011fi i\u00e7in iki tablodan veri al\u0131nmaktad\u0131r. Bunlar; 'Ogrenciler' ve 'Kayit' tablolar\u0131d\u0131r.  E\u011fer tablo ismi uzun ise kolayl\u0131k olmas\u0131 a\u00e7\u0131s\u0131ndan tablo isimleri 'O' ya da 'K' gibi takma isimler (alias) verilerek k\u0131salt\u0131labilir. Bu takma isimler tan\u0131mland\u0131ktan sonra se\u00e7ilecek alan\u0131n isminin belirtilmesi \u00f6nemlidir. 'Ogrenciler' tablosundaki 'isim' s\u00fctunu se\u00e7mek i\u00e7in s\u00fctun ad\u0131n\u0131n ba\u015f\u0131na 'O' eklenir. 'Kayit' tablosundaki 'kurs_no' s\u00fctununu se\u00e7mek i\u00e7in s\u00fctun ad\u0131n\u0131n ba\u015f\u0131na 'K' eklenir."
      },
      {
        "line": "      WHERE O.ogr_no = K.ogr_no AND K.not = \"A\";\n",
        "comment": "Bu \u015fartta, tablo takma ad\u0131 kullan\u0131lm\u0131\u015ft\u0131r. Hem 'Ogrenciler' hem de 'Kayit' tablolar\u0131ndaki 'ogr_no' alan\u0131 kar\u015f\u0131la\u015ft\u0131r\u0131lm\u0131\u015ft\u0131r. Ayr\u0131ca 'A' puan\u0131na sahip olan \u00f6\u011frenciler \u015fart olarak tan\u0131mlanm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataSelection16_version_1_TR": {
    "name": "MultipleTableSelection(2)_version_1_TR",
    "description": "Multiple Table Selection (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT mus_adi, B.borc_no, S.miktar\n",
        "comment": ""
      },
      {
        "line": "     FROM borc_alanlar AS B, borc AS S\n",
        "comment": "Tablo takma adlar\u0131 (alias) FROM ifadesinden sonra 'AS' kelimesi ile birlikte tan\u0131mlan\u0131r. Ancak 'AS' ifadesini kullanmak zorunlu de\u011fildir. E\u011fer tablo ismi uzunsa, k\u0131sa takma isim verilebilir. E\u011fer bir sorgu di\u011fer kullan\u0131c\u0131 tablosuna referans ediyorsa, tablo ismi k\u0131salt\u0131labilir."
      },
      {
        "line": "     WHERE B.borc_no = S.borc_no;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection18_version_1_TR": {
    "name": "AlphabeticOrder_version_1_TR",
    "description": "Alphabetic Order_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT DISTINCT mus_adi\n",
        "comment": "DISTINCT, sonu\u00e7 sat\u0131rlar\u0131n\u0131n ayn\u0131lar\u0131n\u0131 elemine eder. Bu nedenle m\u00fc\u015fteri bor\u00e7lar\u0131 tekrars\u0131z bir \u015fekilde s\u0131ras\u0131yla g\u00f6r\u00fcnt\u00fclenecektir. "
      },
      {
        "line": "     FROM borc_alanlar AS B, borc AS S\n",
        "comment": "Hem 'borc_alanlar' hem de 'borc' tablolar\u0131 i\u00e7in takma adlar (alias) tan\u0131mlan\u0131r. Tablo takma adlar\u0131, e\u011fer tablo ismi \u00e7ok uzunsa ya da programc\u0131ya kolayl\u0131k sa\u011flamak i\u00e7in kullan\u0131labilir."
      },
      {
        "line": "     WHERE B.borc_no = S.borc_no\n",
        "comment": "'borc_alanlar' tablosundaki 'borc_no', 'borc' tablosundaki 'borc_no' ile e\u015fle\u015ftirilir."
      },
      {
        "line": "     ORDER BY mus_adi;",
        "comment": "ORDER BY ifadesi kay\u0131tlar\u0131 belirtilen alanda b\u00fcy\u00fckten k\u00fc\u00e7\u00fc\u011fe veya k\u00fc\u00e7\u00fckten b\u00fcy\u00fc\u011fe g\u00f6re s\u0131ralar. ASC (ascending) parametresi ile k\u00fc\u00e7\u00fckten b\u00fcy\u00fc\u011fe, DESC (descending) parametresi ile b\u00fcy\u00fckten k\u00fc\u00e7\u00fc\u011fe g\u00f6re s\u0131ralar. Burada sadece say\u0131sal alanlar de\u011fil metinsel alanlarda alfabetik olarak s\u0131ralanabilir.  ASC ya da DESC ifadeleri alan ad\u0131n\u0131n sa\u011f taraf\u0131na yaz\u0131l\u0131r. E\u011fer DESC ya da ASC ifadeleri yaz\u0131lmazsa default olarak k\u00fc\u00e7\u00fckten b\u00fcy\u00fc\u011fe olacak \u015fekilde s\u0131ralama yapar. "
      }
    ]
  },
  "DataSelection19_version_1_TR": {
    "name": "CombiningQueryResults(1)_version_1_TR",
    "description": "Combining Query Results (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "(SELECT mus_adi\n",
        "comment": "\u0130lk SELECT ifadesi para yat\u0131ran m\u00fc\u015fterileri se\u00e7mek i\u00e7indir."
      },
      {
        "line": "     FROM para_yatiranlar)\n",
        "comment": ""
      },
      {
        "line": "     UNION\n",
        "comment": "UNION operat\u00f6r\u00fc, iki ya da daha fazla sorgunun sonu\u00e7lar\u0131n\u0131,  tek bir tabloda birle\u015ftirmek i\u00e7in kullan\u0131l\u0131r. UNION operat\u00f6r\u00fcn\u00fcn en b\u00fcy\u00fck s\u0131n\u0131rl\u0131l\u0131\u011f\u0131, iki tablo da ayn\u0131 say\u0131da alan i\u00e7ermesi gerekir. (Select ifadesinden sonra yaz\u0131lacak alan say\u0131s\u0131 her iki sorgu ifadesinde de ayn\u0131 olmal\u0131d\u0131r. Alan adlar\u0131 farkl\u0131 olabilir. ) Her iki tablonun da her bir alan\u0131n\u0131n veri t\u00fcr\u00fc ayn\u0131 olmal\u0131d\u0131r. \u00c7\u00fcnk\u00fc UNION operator\u00fc sorgu sonu\u00e7lar\u0131n\u0131 birle\u015ftirir. UNION operat\u00f6r\u00fc, iki tablodaki alanlar birle\u015ftirilirken tekrarlayan kay\u0131tlar bir defa al\u0131n\u0131r. E\u011fer tekrarlayan kay\u0131tlar\u0131n al\u0131nmas\u0131 isteniyorsa UNION ALL kullan\u0131lmal\u0131d\u0131r."
      },
      {
        "line": "(SELECT mus_adi\n",
        "comment": "\u0130kinci SELECT ifadesi borcu olan m\u00fc\u015fterileri se\u00e7mek i\u00e7indir."
      },
      {
        "line": "     FROM borc_alanlar);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection20_version_1_TR": {
    "name": "CombiningQueryResults(2)_version_1_TR",
    "description": "Combining Query Results (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "(SELECT mus_adi\n",
        "comment": "\u0130lk SELECT ifadesi para yat\u0131ran m\u00fc\u015fterileri se\u00e7mek i\u00e7indir."
      },
      {
        "line": "     FROM para_yatiranlar)\n",
        "comment": ""
      },
      {
        "line": "     INTERSECT\n",
        "comment": "INTERSECT operat\u00f6r\u00fc iki farkl\u0131 sorgu sonucunun kesi\u015fimini elde etmek i\u00e7in kullan\u0131lmaktad\u0131r. Yani iki sorgu sonucunu INSERSECT operat\u00f6r\u00fc ile birle\u015ftirdi\u011fimizde her iki sorgu sonucunda da d\u00f6nen kay\u0131tlar listelenecektir. Her iki tablonun ayn\u0131 say\u0131da alan i\u00e7ermesi ve her iki tablonun her bir alan\u0131n veri t\u00fcr\u00fcn\u00fcn ayn\u0131 olmas\u0131 \u00f6nemlidir.  INTERSECT operat\u00f6r\u00fc, ayn\u0131 tekrarlanan kay\u0131rlar\u0131 bir defa al\u0131r. E\u011fer tekrarlana kay\u0131tlar\u0131n da kalmas\u0131 isteniyorsa INTERSECT ALL ifadesi kullan\u0131lmas\u0131 gerekir."
      },
      {
        "line": "(SELECT mus_adi\n",
        "comment": "Bu soru bor\u00e7lu olan m\u00fc\u015fterileri bulmak i\u00e7indir."
      },
      {
        "line": "     FROM borc_alanlar);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection21_version_1_TR": {
    "name": "CombiningQueryResults(3)_version_1_TR",
    "description": "Combining Query Results (3)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "(SELECT mus_adi\n",
        "comment": "\u0130lk sorgu para yat\u0131ran m\u00fc\u015fterileri se\u00e7mek i\u00e7indir."
      },
      {
        "line": "     FROM para_yatiranlar)\n",
        "comment": ""
      },
      {
        "line": "     EXCEPT\n",
        "comment": "EXCEPT operat\u00f6r\u00fc de iki farkl\u0131 sorgu sonucunun kar\u015f\u0131la\u015ft\u0131r\u0131rken sadece ilk sonu\u00e7 setinde olup ikinci sorgu sonucunda olmayan kay\u0131tlar\u0131 listelememizi sa\u011flamaktad\u0131r. Her iki tablonun ayn\u0131 say\u0131da alan i\u00e7ermesi ve her iki tablonun her bir alan\u0131n veri t\u00fcr\u00fcn\u00fcn ayn\u0131 olmas\u0131 \u00f6nemlidir.  EXCEPT operat\u00f6r\u00fc, ayn\u0131 tekrarlanan kay\u0131rlar\u0131 bir defa al\u0131r. E\u011fer tekrarlana kay\u0131tlar\u0131n da kalmas\u0131 isteniyorsa EXCEPT ALL ifadesi kullan\u0131lmas\u0131 gerekir."
      },
      {
        "line": "     (SELECT mus_adi\n",
        "comment": "\u0130kinci SELECT ifadesi borcu olan m\u00fc\u015fterileri bulmak i\u00e7indir."
      },
      {
        "line": "     FROM borc_alanlar);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection30_version_1_TR": {
    "name": "ComparingSubqueryResults(1)_version_1_TR",
    "description": "Comparing Subquery Results (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT sube_name\n",
        "comment": ""
      },
      {
        "line": "     FROM sube\n",
        "comment": ""
      },
      {
        "line": "     WHERE varliklar> SOME\n",
        "comment": "SOME testi, alt sorgu sonu\u00e7lar\u0131 ile test de\u011ferlerini kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in SQL kar\u015f\u0131la\u015ft\u0131rma operat\u00f6rlerinden(=, <>, <, <=, >, >=) biri ile birlikte kullan\u0131l\u0131r. E\u011fer alt sorgu taraf\u0131ndan d\u00f6nd\u00fcr\u00fclen sat\u0131rlardan en az biriyle kar\u015f\u0131la\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda ko\u015fulu sa\u011flayan sat\u0131ra ula\u015f\u0131l\u0131rsa, SOME test sonucu TRUE (do\u011fru) sonucunu d\u00f6nd\u00fcr\u00fcr. SOME ve ANY ifadeleri ayn\u0131d\u0131r. Bu \u00f6rnekte, her bir \u015fubenin varl\u0131k de\u011feri ile 'Ankara' ilindeki \u015fubelerin her bir varl\u0131k de\u011feri kar\u015f\u0131la\u015ft\u0131r\u0131lm\u0131\u015ft\u0131r."
      },
      {
        "line": "          (SELECT varliklar\n",
        "comment": "'Ankara' ilindeki \u015fubelerin mevcut varl\u0131k de\u011ferlerini bulmak i\u00e7indir."
      },
      {
        "line": "           FROM sube\n",
        "comment": ""
      },
      {
        "line": "          WHERE sube_sehri= 'Ankara');\n",
        "comment": ""
      }
    ]
  },
  "DataSelection31_version_1_TR": {
    "name": "ComparingSubqueryResults(2)_version_1_TR",
    "description": "Comparing Subquery Results (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT sube_adi\n",
        "comment": ""
      },
      {
        "line": "     FROM sube\n",
        "comment": ""
      },
      {
        "line": "     WHERE varliklar> ALL\n",
        "comment": "ALL testi, alt sorgu sonu\u00e7lar\u0131 ile test de\u011ferlerini kar\u015f\u0131la\u015ft\u0131rmak i\u00e7in SQL kar\u015f\u0131la\u015ft\u0131rma operat\u00f6rlerinden(=, <>, <, <=, >, >=) biri ile birlikte kullan\u0131l\u0131r. E\u011fer yap\u0131lan kar\u015f\u0131la\u015ft\u0131rma sonucunda alt sorgu kay\u0131tlar\u0131n\u0131n t\u00fcm\u00fc ana sorgu kayd\u0131yla e\u015fle\u015fiyorsa, ALL testi sonucu TRUE (do\u011fru) sonucunu d\u00f6nd\u00fcr\u00fcr. Bu \u00f6rnekte, her bir \u015fubenin varl\u0131k de\u011feri,  'Ankara' ilindeki her bir \u015fubenin varl\u0131k de\u011feri ile kar\u015f\u0131la\u015ft\u0131r\u0131lm\u0131\u015ft\u0131r. 'Ankara' ilindeki \u015fubelerin t\u00fcm de\u011ferleri, di\u011fer \u015fubelerin varl\u0131k de\u011ferinden daha k\u00fc\u00e7\u00fck olup olmad\u0131\u011f\u0131 kontrol edilmi\u015ftir."
      },
      {
        "line": "          (SELECT varliklar\n",
        "comment": "'Ankara' ilindeki \u015fubelerin mevcut varl\u0131k de\u011ferlerini bulmak i\u00e7indir."
      },
      {
        "line": "           WHERE sube_sehri= 'Ankara');\n",
        "comment": ""
      }
    ]
  },
  "DataSelection5_version_1_TR": {
    "name": "AggregateFunctions(1)_version_1_TR",
    "description": "Aggregate Functions (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT AVG(not_ort) \n",
        "comment": "AVG() fonksiyonu, belirlenen bir alan i\u00e7indeki verilerin ortalamas\u0131n\u0131 hesaplar.\nBu \u00f6rnekte, 'not_ort' s\u00fctunun ortalamas\u0131 hesaplanm\u0131\u015f ve tek bir ortalama de\u011fer \u00fcretilmi\u015ftir."
      },
      {
        "line": "      FROM Ogrenciler;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection22_version_1_TR": {
    "name": "AggregateFunctions(2)_version_1_TR",
    "description": "Aggregate Functions (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT AVG(bakiye)\n",
        "comment": "AVG() fonksiyonu, belirlenen bir alan i\u00e7indeki verilerin ortalamas\u0131n\u0131 hesaplar ve sadece tek bir ortalama de\u011fer al\u0131r. Alandaki verinin, say\u0131sal tipte olmas\u0131 gerekir."
      },
      {
        "line": "     FROM hesap\n",
        "comment": ""
      },
      {
        "line": "     WHERE sube_adi= 'Yenimahalle';",
        "comment": "Bu sorguda, sadece 'Yenimahalle' \u015fubesindeki bakiyelerin ortalamas\u0131 hesaplanmaktad\u0131r."
      }
    ]
  },
  "DataSelection23_version_1_TR": {
    "name": "AggregateFunctions(3)_version_1_TR",
    "description": "Aggregate Functions (3)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT COUNT(*) \n",
        "comment": "COUNT() fonksiyonu, kay\u0131tlar\u0131n toplam say\u0131s\u0131n\u0131 hesaplar. E\u011fer alan ad\u0131, i\u015flemin bir par\u00e7as\u0131 olarak belirlenmi\u015fse, bir alandaki de\u011ferlerin say\u0131s\u0131n\u0131 hesaplar. \u00d6rn: COUNT(mus_adi) ifadesi, 'mus_adi' alann\u0131ndaki de\u011ferlerin toplam say\u0131s\u0131n\u0131 hesaplar. COUNT(*) sorgu sonucundaki t\u00fcm kay\u0131tlar\u0131n say\u0131s\u0131n\u0131 hesaplar."
      },
      {
        "line": "     FROM musteriler;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection24_version_1_TR": {
    "name": "AggregateFunctions(4)_version_1_TR",
    "description": "Aggregate Functions (4)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT COUNT(DISTINCT mus_adi) \n",
        "comment": "DISTINCT kelimesi, yinelenen kay\u0131tlar\u0131n elemine edilmesi i\u00e7in kullan\u0131l\u0131r. B\u00f6ylece sadece benzersiz m\u00fc\u015fteri adlar\u0131 al\u0131n\u0131r. Yinelenen kald\u0131r\u0131ld\u0131ktan sonra, COUNT () fonksiyonu mus_adi s\u00fctunundaki kay\u0131tlar\u0131n toplam say\u0131s\u0131n\u0131 hesaplar."
      },
      {
        "line": "     FROM para_yatiranlar;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection25_version_1_TR": {
    "name": "GroupedQueries_version_1_TR",
    "description": "Grouped Queries_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT sube_adi, AVG(bakiye)\n",
        "comment": "GROUP BY kullanarak, sonu\u00e7lar \u015fube ad\u0131na g\u00f6re grupland\u0131r\u0131lm\u0131\u015f. Her bir gruptaki \u015fube i\u00e7in ortalama bakiye hesaplanm\u0131\u015ft\u0131r."
      },
      {
        "line": "     FROM hesap\n",
        "comment": ""
      },
      {
        "line": "     GROUP BY sube_adi;",
        "comment": "GROUP BY ifadesi, kaynak tablolardan elde edilen verilerin grupland\u0131r\u0131lmas\u0131n\u0131 sa\u011flar. Her bir sat\u0131r grubu i\u00e7in tek \u00f6zet sat\u0131r \u00fcretir. Bu \u00f6rnekte; sonu\u00e7lar \u015fube ad\u0131na g\u00f6re grupland\u0131r\u0131lm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataSelection26_version_1_TR": {
    "name": "GroupedQuerieswithCondition_version_1_TR",
    "description": "Grouped Queries with Condition_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT sube_adi, AVG(bakiye)\n",
        "comment": ""
      },
      {
        "line": "     FROM hesap\n",
        "comment": ""
      },
      {
        "line": "     GROUP BY sube_adi\n",
        "comment": "Sonu\u00e7 verisi her bir \u015fube ismi i\u00e7in \u00f6zetlenmi\u015f ve grupland\u0131r\u0131lm\u0131\u015ft\u0131r."
      },
      {
        "line": "     HAVING AVG(bakiye) > 600;\n",
        "comment": "\nWHERE ifadesi gibi HAVING ifadesi de sat\u0131r gruplar\u0131n\u0131 se\u00e7mek i\u00e7in kullan\u0131l\u0131r.\n'GROUP BY' ifadesi kullan\u0131larak, veriler grupland\u0131r\u0131l\u0131r ve \u015fube isimlerine g\u00f6re alt toplamlar hesaplan\u0131r ve sonra alt toplamlar\u0131n ortalamas\u0131 hesaplan\u0131r. E\u011fer alt toplam ortalamas\u0131 600'den b\u00fcy\u00fck ise veri \u00e7ekilir. Asl\u0131nda HAVING ifadesinin i\u015flevi WHERE ifadesininkine \u00e7ok benzerdir. Ancak k\u00fcmeleme(gruplama) fonksiyonlar\u0131 ile WHERE ifadesi birlikte kullan\u0131lamad\u0131\u011f\u0131ndan HAVING ifadesine ihtiya\u00e7 duyulmu\u015ftur. \n"
      }
    ]
  },
  "DataSelection32_version_1_TR": {
    "name": "AggregatingSubquery_version_1_TR",
    "description": "Aggregating Subquery_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT sube_adi \n",
        "comment": "\u0130lk olarak alt sorguda, t\u00fcm \u015fubelerin ortalama de\u011feri hesapland\u0131. Sonras\u0131nda ALL testi kullan\u0131larak her bir \u015fubenin ortalama hesap de\u011feri alt sorgu sonucu ile kar\u015f\u0131la\u015ft\u0131r\u0131ld\u0131."
      },
      {
        "line": "     FROM hesap\n",
        "comment": "Bu sorgu, en y\u00fcksek ortalama hesap bakiyesini bulmak i\u00e7indir."
      },
      {
        "line": "     GROUP BY sube_adi \n",
        "comment": "\u015eubeye g\u00f6re hesap bakiyelerini grupland\u0131rmak i\u00e7in kullan\u0131lmaktad\u0131r."
      },
      {
        "line": "     HAVING AVG(bakiye) >= ALL \n",
        "comment": "Bu \u015fart, ALL test kullan\u0131larak en y\u00fcksek ortalama hesap bakiyesini bulmak i\u00e7indir. Asl\u0131nda HAVING ifadesinin i\u015flevi WHERE ifadesininkine \u00e7ok benzer. Ancak k\u00fcmeleme(gruplama) fonksiyonlar\u0131 ile WHERE ifadesi birlikte kullan\u0131lamad\u0131\u011f\u0131ndan HAVING ifadesine ihtiya\u00e7 duyulmu\u015ftur. >= kar\u015f\u0131la\u015ft\u0131rmas\u0131 yapmak i\u00e7in \u015fube ad\u0131na g\u00f6re bakiyeler grupland\u0131r\u0131lm\u0131\u015f ve ortalama de\u011fer hesaplanm\u0131\u015ft\u0131r. Alt sorgu sonucunda hesaplanan her bir de\u011fer, her bir \u015fubenin t\u00fcm ortalama de\u011feri ile kar\u015f\u0131la\u015ft\u0131r\u0131lm\u0131\u015f ve e\u011fer \u015fart sa\u011flanm\u0131\u015fsa, TRUE sonucu \u00fcretilmi\u015ftir."
      },
      {
        "line": "          (SELECT AVG(bakiye) \n",
        "comment": "Her bir \u015fubenin ortalama hesap bakiyesi hesaplanm\u0131\u015ft\u0131r."
      },
      {
        "line": "           FROM hesap\n",
        "comment": ""
      },
      {
        "line": "           GROUP BY sube_adi);\n",
        "comment": "Hesap bakiyelerini \u015fubeye g\u00f6re grupland\u0131r\u0131lm\u0131\u015f sonra ortalama de\u011feri AVG fonksiyonunda hesaplanm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataSelection36_version_1_TR": {
    "name": "Groupingandaggregating(1)_version_TR",
    "description": "Grouping and aggregating (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT T.t_no, COUNT(*) AS hesap\n",
        "comment": ""
      },
      {
        "line": "     FROM tekneler T, rezervasyonlar R\n",
        "comment": "'tekneler' ve 'rezervasyonlar' tablolar\u0131 s\u0131ras\u0131yla T ve R olarak isimlendirilmi\u015ftir."
      },
      {
        "line": "     WHERE R.t_no= T.t_no AND T.renk = k\u0131rm\u0131z\u0131\n",
        "comment": "Burada iki \u015fart s\u0131nanmaktad\u0131r.\u0130lk olarak, 'rezervasyonlar' tablosundaki 't_no' ile 'tekneler' tablosundaki 't_no' numaralar\u0131 e\u015fle\u015ftirilerek, rezerve edilip edilmedi\u011fi test edilir. \u0130kinci olarak teknenin renginin k\u0131rm\u0131z\u0131 olup olmad\u0131\u011f\u0131 test edilir."
      },
      {
        "line": "     GROUP BY T.t_no;\n",
        "comment": "COUNT fonksiyonu, GROUP BY ifadesi ile \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r. Sat\u0131r say\u0131lar\u0131n\u0131 hesaplamak i\u00e7in, sonu\u00e7lar 't_no' ya g\u00f6re grupland\u0131r\u0131l\u0131r. Sonra COUNT fonksiyonu \u00e7al\u0131\u015ft\u0131r\u0131l\u0131r."
      }
    ]
  },
  "DataSelection37_version_1_TR": {
    "name": "Groupingandaggregating(2)_version_1_TR",
    "description": "Grouping and aggregating (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT D.derece, MIN (D.yas)\n",
        "comment": ""
      },
      {
        "line": "     FROM denizciler D\n",
        "comment": ""
      },
      {
        "line": "     WHERE D.yas> 18\n",
        "comment": "Bu \u00f6rnekte t\u00fcm denizciler de\u011fil, sadece 18 ya\u015f\u0131ndan b\u00fcy\u00fck denizciler se\u00e7ilmektedir."
      },
      {
        "line": "     GROUP BY D.derece\n",
        "comment": "Denizciler, sahip olduklar\u0131 derecelere g\u00f6re grupland\u0131r\u0131lmaktad\u0131r."
      },
      {
        "line": "     HAVING 1 < \n",
        "comment": "Bu sorguda ilk olarak derece s\u0131n\u0131rland\u0131rmas\u0131 en az iki denizci olarak belirlenmi\u015ftir. Her bir derecedeki toplam denizci say\u0131s\u0131, 1 ile kar\u015f\u0131la\u015ft\u0131r\u0131lm\u0131\u015ft\u0131r."
      },
      {
        "line": "         (SELECT COUNT(*) \n",
        "comment": "Alt sorgu, her bir dereceye ait denizci say\u0131s\u0131n\u0131 hesaplamak i\u00e7indir."
      },
      {
        "line": "          FROM denizciler D2\n",
        "comment": ""
      },
      {
        "line": "          WHERE D.derece= D2.derece);\n",
        "comment": "Denizciler tablosundaki dereceler, grup dereceleri ile e\u015fle\u015ftirilir."
      }
    ]
  },
  "DataSelection38_version_1_TR": {
    "name": "Groupingandaggregating(3)_version_1_TR",
    "description": "Grouping and aggregating (3)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT D.derece \n",
        "comment": ""
      },
      {
        "line": "     FROM denizciler D\n",
        "comment": ""
      },
      {
        "line": "     WHERE D.yas = \n",
        "comment": ""
      },
      {
        "line": "         (SELECT MIN (AVG(D2.yas)) \n",
        "comment": "Bu \u00f6rnek YANLI\u015et\u0131r. \u00c7\u00fcnk\u00fc k\u00fcmeleme operat\u00f6rleri i\u00e7 i\u00e7e kullan\u0131lamaz. Bu sorgu, denizcilerin ortalama ya\u015f\u0131n\u0131 ve bunun en d\u00fc\u015f\u00fck de\u011feri hesaplamaya \u00e7al\u0131\u015f\u0131yor. Ancak AVG fonsiyonu di\u011fer k\u00fcmeleme fonksiyonlar\u0131yla  i\u00e7 i\u00e7e kullan\u0131lamaz."
      },
      {
        "line": "          FROM denizciler D2);",
        "comment": ""
      }
    ]
  },
  "DataSelection28_version_1_TR": {
    "name": "NestedSubqueries(1)_version_1_TR",
    "description": "Nested Subqueries (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT DISTINCT mus_adi\n",
        "comment": "\u0130lk olarak parantez i\u00e7erisindeki sorgu hesaplan\u0131r. Sonra \u00fcyelik testi i\u015flemi (IN) yap\u0131l\u0131r. Sonu\u00e7lar, ana sorgu sonucuyla kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r. DISTINCT ifadesi ile m\u00fc\u015fteri ismine g\u00f6re tekrar eden kay\u0131tlar elemine edilmi\u015ftir. "
      },
      {
        "line": "     FROM borc_alanlar\n",
        "comment": ""
      },
      {
        "line": "     WHERE mus_adi IN \n",
        "comment": "IN \u00fcyelik testi, veri de\u011ferinin, hedef de\u011ferler listesinden bir de\u011fer ile e\u015fle\u015fip e\u015fle\u015fmedi\u011fini kontrol eder. \u00d6rne\u011fin: 'X IN (A, B, C) ifadesi '(X=A) OR (X=B) OR (X=C)' ifadene e\u015fittir. Bu \u00f6rnekte, m\u00fc\u015fteri ismi, 'para_yatiranlar' tablosundaki m\u00fc\u015fteri isimleri isimleriyle test edilmektedir. "
      },
      {
        "line": "          (SELECT mus_adi\n",
        "comment": "SQL i\u00e7 i\u00e7e alt sorgu i\u00e7in bir mekanizma sa\u011flar. Bir alt sorgu i\u00e7erisinde 'SELECT FROM WHERE', 'GROUP BY' ya da 'HAVING' ifadeleri yer alabilir. Bu sorgu, hesap bakiyesi olan m\u00fc\u015fteri isimlerini bulmak i\u00e7indir."
      },
      {
        "line": "           FROM para_yatiranlar);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection29_version_1_TR": {
    "name": "NestedSubqueries(2)_version_1_TR",
    "description": "Nested Subqueries (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT DISTINCT mus_adi\n",
        "comment": "\u0130lk olarak alt sorguda para yat\u0131ran m\u00fc\u015fteriler se\u00e7ilir. Sonra borcu olan m\u00fc\u015fteriler, alt sorgu sonu\u00e7lar\u0131yla kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r."
      },
      {
        "line": "     FROM borc_alanlar\n",
        "comment": ""
      },
      {
        "line": "     WHERE mus_adi NOT IN \n",
        "comment": "NOT IN ifadesi ile alt sorgudan \u00e7\u0131kan sonu\u00e7lar (para yat\u0131ran m\u00fc\u015fteriler) haricindeki m\u00fc\u015fteri isimlerinin listelenmesi sa\u011flan\u0131r."
      },
      {
        "line": "          (SELECT mus_adi\n",
        "comment": "Bu altsorgu hesab\u0131 olan m\u00fc\u015fterileri bulmak i\u00e7indir."
      },
      {
        "line": "           FROM para_yatiranlar);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection27_version_1_TR": {
    "name": "CheckingNullValues_version_1_TR",
    "description": "Checking Null Values_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT borc_no\n",
        "comment": ""
      },
      {
        "line": "     FROM borc\n",
        "comment": ""
      },
      {
        "line": "     WHERE miktar IS NULL;\n",
        "comment": "Bir alandaki de\u011fer girilmemi\u015f kay\u0131tlar listelenmek istenirse IS NULL deyimi kullan\u0131labilir. E\u011fer kar\u015f\u0131la\u015ft\u0131r\u0131lan de\u011fer, NULL ise sonu\u00e7 TRUE d\u00f6ner. NULL, de\u011ferin belirsiz oldu\u011funu ifade eder. NULL ifadesi di\u011fer ko\u015fullar ile kullan\u0131lamaz. Yani 'miktar >NULL' diye bir \u015fey diyemeyiz.  \u00c7\u00fcnk\u00fc bilinen bir de\u011fer ile bilinmeyen bir de\u011fer kar\u015f\u0131la\u015ft\u0131r\u0131lamaz. Bu sebeple bunun sonucunda TRUE ya da FALSE gibi bir ifade d\u00f6nmesi imk\u00e2ns\u0131zd\u0131r."
      }
    ]
  },
  "DataSelection33_version_1_TR": {
    "name": "DerivedRelations_version_1_TR",
    "description": "Derived Relations_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT sube_adi, ort_bakiye\n",
        "comment": "Bu \u00f6rnekte, t\u00fcretilmi\u015f bir alt tablo kullan\u0131lm\u0131\u015ft\u0131r. Ana sorguda kullan\u0131lan alanlar,  'hesap' tablosundan gelmemektedir. Alt sorgudan t\u00fcretilen ve sube_ort takma ad\u0131 (alias) verilen tablodan \u00e7ekmektedir."
      },
      {
        "line": "     FROM\n",
        "comment": "Bu t\u00fcretilmi\u015f tablo, FROM ifadesinden sonra gelen SELECT ifadesinin parantez i\u00e7ine al\u0131n\u0131p bir takma ad verilmesidir."
      },
      {
        "line": "          (SELECT sube_adi, AVG(bakiye)\n",
        "comment": "Bu alt sorgu, \u015fubenin ortalama hesap de\u011ferlerini ve \u015fube isimlerini se\u00e7mek i\u00e7indir."
      },
      {
        "line": "           FROM hesap\n",
        "comment": "HAVING ifadesini kullanmaya gerek yoktur \u00e7\u00fcnk\u00fc FROM ifadesinde 'sube_ort'  ge\u00e7ici ili\u015fkisini hesaplanmaktad\u0131r ve WHERE ifadesinde do\u011frudan kullan\u0131labilmektedir."
      },
      {
        "line": "           GROUP BY sube_adi)\n",
        "comment": "T\u00fcretilen ili\u015fkide GROUP BY ifadesi kullan\u0131lm\u0131\u015ft\u0131r."
      },
      {
        "line": "           AS sube_ort (sube_adi, ort_bakiye))\n",
        "comment": "AS ifadesi ile 'sube_adi' ve 'ort_bakiye' isminde iki alana sahip 'sube_ort' ad\u0131nda ge\u00e7ici bir tablo olu\u015fturulmu\u015ftur."
      },
      {
        "line": "    WHERE ort_bakiye > 1200;\n",
        "comment": "'ort_bakiye' alan\u0131n\u0131n de\u011ferini s\u0131n\u0131rland\u0131rmak i\u00e7in WHERE ifadesi kullan\u0131lm\u0131\u015ft\u0131r. HAVING ifadesinin kullan\u0131m\u0131na gerek yoktur."
      }
    ]
  },
  "DataSelection34_version_1_TR": {
    "name": "ViewCreation(1)_version_1_TR",
    "description": "View Creation (1)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE VIEW v AS \n",
        "comment": "VIEW ifadesinin temel amac\u0131 tablolar\u0131n i\u00e7erisinden veri k\u00fcmesi getirip ortaya \u00e7\u0131kan sonucu sanal tabloymu\u015f gibi yeniden sorgulayabilmemizi sa\u011flamakt\u0131r. K\u0131saca SQL'de verilerimizin iste\u011fe ba\u011fl\u0131 alanlara ve tablolara g\u00f6re ekran\u0131m\u0131zda g\u00f6r\u00fcnteleme i\u015flemi yapmam\u0131z\u0131 sa\u011flar. Veritaban\u0131 VIEW ile olu\u015fan veriler  saklamaz. SQL deyimi her \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda ilgili VIEW sanal tablo yeniden olu\u015fturulur.  Yeni bir view i\u00e7in SQL 'CREATE VIEW' ifadesi ile ba\u015flamal\u0131d\u0131r. Ard\u0131ndan isim yaz\u0131lmal\u0131d\u0131r. VIEW alanlar\u0131 'AS' anahtar kelimesinden sonra tan\u0131mlan\u0131r."
      },
      {
        "line": "     (SELECT mus_adi, borc_no \n",
        "comment": "Bu, VIEW tan\u0131mlamak i\u00e7in bir sorgudur. Bu sorgu ile borcu olan m\u00fc\u015fteriler ve bor\u00e7lu m\u00fc\u015fterilerin numaralar\u0131 se\u00e7ilir."
      },
      {
        "line": "      FROM borc_alanlar, borc\n",
        "comment": ""
      },
      {
        "line": "      WHERE borc_alanlar.borc_no = borc.borc_no);\n",
        "comment": "'borc_alanlar' tablosundaki 'borc_no' ile 'borc' tablosundaki 'borc_no' kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r ve e\u015fit olanlar belirlenir."
      }
    ]
  },
  "DataSelection35_version_1_TR": {
    "name": "ViewCreation(2)_version_1_TR",
    "description": "View Creation (2)_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "CREATE VIEW tum_musteriler AS \n",
        "comment": "CREATE VIEW deyimi ile \u00e7oklu tablo birle\u015fimi ger\u00e7ekle\u015ftirilir ve 'tum_musteriler' isimli sanal tablo olu\u015fturulur. "
      },
      {
        "line": "    (SELECT sube_adi, mus_adi\n",
        "comment": "\u0130lk sorgu para yat\u0131ran m\u00fc\u015fterileri ve \u015fubeleri bulmak i\u00e7indir."
      },
      {
        "line": "        FROM para_yatiranlar, hesap\n",
        "comment": ""
      },
      {
        "line": "        WHERE para_yatiranlar.hesap_no = hesap.hesap_no)\n",
        "comment": ""
      },
      {
        "line": "     UNION\n",
        "comment": "UNION deyimiyle birlikte ayr\u0131 sorgulardan elde edilen sonu\u00e7lar birle\u015ftirilir. "
      },
      {
        "line": "    (SELECT sube_adi, mus_adi",
        "comment": "\u0130kinci sorgu borcu olan m\u00fc\u015fteriler ve \u015fubeleri bulmak i\u00e7indir."
      },
      {
        "line": "        FROM borc_alanlar, borc\n",
        "comment": ""
      },
      {
        "line": "        WHERE borc_alanlar.borc_no = borc.borc_no);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection40_version_1_TR": {
    "name": "Retrievingdatafromview_version_1_TR",
    "description": "Retrieving data from view_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT mus_adi\n",
        "comment": ""
      },
      {
        "line": "      FROM tum_musteriler\n",
        "comment": "VIEW deyimi ile olu\u015fturulmu\u015f  'tum_musteriler' ismindeki sanal tablodan veriler \u00e7ekilmektedir."
      },
      {
        "line": "      WHERE sube_adi= 'Yenimahalle';\n",
        "comment": "Sonu\u00e7lar, \u015fube ad\u0131 'Yenimahalle' olan kay\u0131tlarla s\u0131n\u0131rland\u0131r\u0131lm\u0131\u015ft\u0131r."
      }
    ]
  },
  "DataSelection41_version_1_TR": {
    "name": "AggregatingDerivedRelations_version_1_TR",
    "description": "Aggregating Derived Relations_TR",
    "language": "sql",
    "author": "ayca",
    "lines": [
      {
        "line": "SELECT gecici.derece, gecici.ortyas\n",
        "comment": "Her bir alan\u0131n \u00f6n\u00fcndeki 'gecici' ifadesi, t\u00fcretilen tablonun ismidir. "
      },
      {
        "line": "     FROM \n",
        "comment": ""
      },
      {
        "line": "        (SELECT D.derece, AVG(D.yas) AS ortyas\n",
        "comment": "Bu alt sorgu FROM ile kullan\u0131l\u0131r. \u00c7\u00fcnk\u00fc bu t\u00fcretilen tablodur.  Denizcilerin sahip oldu\u011fu dereceler ve ortalama ya\u015f\u0131 alanlar\u0131n\u0131 i\u00e7ermektedir. Derecelerine g\u00f6re denizciler grupland\u0131r\u0131l\u0131rlar ve 'ortyas' olarak yeniden isimlendirilir."
      },
      {
        "line": "         FROM denizciler D\n",
        "comment": ""
      },
      {
        "line": "         GROUP BY D.derece) AS gecici\n",
        "comment": "T\u00fcretilen t\u00fcm alt sorgular 'gecici' olarak yeniden isimlendirilir.  T\u00fcretilen tablolar isimlendirildikten sonra yeni isim d\u0131\u015f sorguda kullan\u0131l\u0131r."
      },
      {
        "line": "     WHERE gecici.ort_yas= \n",
        "comment": "T\u00fcretilen tablodaki  'ort_yas'  alan\u0131n\u0131ndaki de\u011fer ile ikinci alt sorgu ile elde edilen de\u011ferin e\u015fitli\u011fi kar\u015f\u0131la\u015ft\u0131r\u0131l\u0131r."
      },
      {
        "line": "    (SELECT MIN(gecici.ort_yas) \n",
        "comment": "Bu sorgu t\u00fcretilen tablodaki  'ort_yas'  alan\u0131n\u0131nda yer alan de\u011ferler i\u00e7erisinde en az olan\u0131n\u0131 bulmak i\u00e7indir."
      },
      {
        "line": "     FROM gecici);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection5_version_1": {
    "name": "AggregateFunctions(1)_version_1",
    "description": "Aggregate Functions (1)",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT AVG(gpa) \n",
        "comment": "The AVG() aggregate function takes a column of data and computes its average. In this example, 'gpa' column is averaged out and produces a single average value.\n"
      },
      {
        "line": "      FROM Student;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection5_version_1_pt": {
    "name": "AggregateFunctions",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT AVG(gpa) \n",
        "comment": "A funcao de agregacao AVG() calcula a media dos valores de uma coluna de dados. Neste exemplo, a media dos valores da coluna 'gpa' e' calculada produzindo um unico valor como resultado da consulta."
      },
      {
        "line": "      FROM Student;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection22_version_1_pt": {
    "name": "AggregateFunctions(2)",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT AVG(balance)\n",
        "comment": "A funcao de agregacao AVG() calcula a media dos valores de uma coluna de dados, retornando um unico valor. A coluna deve ser de um tipo numerico."
      },
      {
        "line": "     FROM account\n",
        "comment": ""
      },
      {
        "line": "     WHERE branch_name = 'Perryridge';",
        "comment": "Essa condicao filtra os dados e retorna apenas as linhas cuja coluna branch_name possui o valor 'Perryridge'."
      }
    ]
  },
  "DataSelection23_version_1_pt": {
    "name": "AggregateFunctions(3)",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT COUNT(*) \n",
        "comment": "A funcao de agregacao COUNT() calcula a quantidade de tuplas retornadas. Se o nome da coluna for especificado, a funcao retorna o numero de valores naquela coluna. Por exemplo, COUNT(customer_name) e' utilizado para calcular a quantidade de valores contidos na coluna 'customer_name' e COUNT(*) e' utilizado para contar a quantidade de linhas retornadas pela consulta."
      },
      {
        "line": "     FROM customer;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection24_version_1_pt": {
    "name": "AggregateFunctions(4)",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT COUNT(DISTINCT customer_name) \n",
        "comment": "A palavra-chave DISTINCT e' utilizada para eliminar resultados duplicados, neste caso, retorna os valores unicos da coluna 'customer_name'. Apos eliminar os valores duplicados, a funcao de agregacao COUNT() calcula a quantidade total de valores retornados."
      },
      {
        "line": "     FROM depositor;\n",
        "comment": ""
      }
    ]
  },
  "TableCreation1_version_1_pt": {
    "name": "TableCreation_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE Students\n",
        "comment": "O comando utilizado para criar uma nova tabela comeca com a clausula 'CREATE TABLE' seguida pelo nome da tabela a ser criada. Perceba que nao pode existir uma outra tabela com o mesmo nome no mesmo banco de dados."
      },
      {
        "line": "     (sid VARCHAR(20) NOT NULL,\n",
        "comment": "Coluna com nome 'sid', tipo de dados caractere com no maximo 20 letras e nao permite valores nulos. <br> As colunas da nova tabela criada sao definidas no corpo da clausula CREATE TABLE. Primeiramente, toda coluna da tabela deve possuir um nome unico seguido do tipo de dados que sera armazenado na coluna. Em seguida, deve-se indicar se a coluna requer preenchimento obrigatorio ou nao (permite ou nao valores nulos)."
      },
      {
        "line": "      name VARCHAR(20),\n",
        "comment": "Cada definicao de coluna deve ser separada por uma virgula."
      },
      {
        "line": "      login VARCHAR(10),\n",
        "comment": "O tipo de dados VARCHAR permite que a coluna armazene textos com tamanhos variados a cada linha. O tipo de dados CHAR tambem permite o armazenamento de textos, entretanto seu tamanho e' fixo, independente se o texto armazenado ocupa todo o espaco ou nao."
      },
      {
        "line": "      age INTEGER DEFAULT NULL,\n",
        "comment": "A coluna 'age' e' do tipo inteiro e se nenhum valor for informado, o SGBD automaticamente preenche a tupla com o valor NULL por causa da definicao DEFAULT como 'NULL'."
      },
      {
        "line": "      gpa REAL DEFAULT 0.00);",
        "comment": "A coluna 'gpa' possui o valor padrao 0.00. A clausula 'CREATE TABLE' termina com o fechamento de parenteses. <br><br>Toda consulta SQL termina com ponto-e-virgula (;)."
      }
    ]
  },
  "TableDrop1_version_1_pt": {
    "name": "TableDrop_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "DROP TABLE Students;\n",
        "comment": "A tabela de nome 'Students' e' excluida. As informacoes de schema e as tuplas sao excluidas. Com a devida permissao, voce pode excluir uma de suas tabelas ou uma tabela de outro usuario."
      }
    ]
  },
  "TableAlteration1_version_1_pt": {
    "name": "ColumnAddition_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "ALTER TABLE Students\n",
        "comment": "Clausula ALTER TABLE para incluir a coluna 'firstYear' 'a tabela ja existente 'Students'."
      },
      {
        "line": "      ADD COLUMN firstYear INTEGER;",
        "comment": "The most common use of the ALTER TABLE statement. The column definition clause in the ALTER TABLE statement is just like the one in the CREATE TABLE statement and it works the same way.\nEsse e' o uso mais comum da clausula ALTER TABLE. A definicao da coluna (nome e tipo de dado) acontece da mesma forma que na clausula CREATE TABLE."
      }
    ]
  },
  "TableAlteration2_version_1_pt": {
    "name": "ColumnDrop_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "ALTER TABLE Student\n",
        "comment": "A clausula ALTER TABLE por ser utilizada para excluir uma ou mais colunas de uma tabela existente. Note que a exclusao de uma coluna pode resultar em erros de integridade de dados. Por exemplo, ao excluir uma coluna que e' uma chave primaria em algum relacionamento, as colunas relacionadas com as chaves estrangeiras para a coluna excluida se tornam invalidas."
      },
      {
        "line": "      DROP COLUMN age;\n",
        "comment": "A clausula DROP COLUMN e' seguida pelo nome da coluna a ser excluida - 'age'."
      }
    ]
  },
  "TableCreation2_version_1_pt": {
    "name": "PrimaryKey(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE Enrolled\n",
        "comment": "Essa tabela armazena as informacoes de matricula de cada aluno. Sendo assim, o identificador do aluno e da disciplina sao definidos no schema da tabela 'Enrolled'."
      },
      {
        "line": "     (sid CHAR(20),\n",
        "comment": "'sid' e' o ID do aluno e possui um tamanho fixo de 20 caracteres."
      },
      {
        "line": "      cid CHAR(20),\n",
        "comment": "'cid' e' o ID da disciplina e possui um tamanho fixo de 20 caracteres."
      },
      {
        "line": "      grade CHAR(2),\n",
        "comment": "'grade' e' a nota de cada aluno e possui tamanho fixo de 2 caracteres.\n"
      },
      {
        "line": "      PRIMARY KEY (sid, cid));",
        "comment": "Um aluno pode estar matriculado na mesma disciplina apenas uma vez. Os alunos possuem uma unica nota para cada disciplina, visto que a chave primaria foi definida com ambas as colunas, sid e cid. A chave primaria de uma tabela deve possuir valores unicos para cada linha da tabela."
      }
    ]
  },
  "TableCreation9_version_1_pt": {
    "name": "PrimaryKey(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE course\n",
        "comment": "Esse exemplo mostra a criacao da tabela 'course' com colunas para armazenar o identificador do curso e seu nome."
      },
      {
        "line": "     (cid CHAR(20) NOT NULL PRIMARY KEY,\n",
        "comment": "O identificador do curso e' definido como 'cid'. Essa coluna nao pode ter valores nulos. <br/> <br/>\nA chave primaria especifica um identificador unico para cada linha da tabela. Isso significa que nao existe mais de um curso com o mesmo identificador. Alem disso, a coluna definida como chave primaria nao pode conter valores nulos.\n"
      },
      {
        "line": "      cname CHAR(40));\n",
        "comment": "A coluna 'cname' armazena o nome do curso e possui um tamanho fixo de 40 caracteres."
      }
    ]
  },
  "TableCreation3_version_1_pt": {
    "name": "PrimaryKeyandUniqueKey_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE Enrolled\n",
        "comment": "Tabela para armazenar as matriculas dos alunos. Os alunos podem se matricular apenas uma unica vez em cada disciplina."
      },
      {
        "line": "      sid CHAR(20),\n",
        "comment": "Essa coluna armazena o identificador para o aluno e faz parte de uma chave candidata, definida pela clausula UNIQUE."
      },
      {
        "line": "      cid CHAR(20),\n",
        "comment": "Essa coluna armazena o identificador do curso, que tambem faz parte de uma chave candidata, definida pela clausula UNIQUE."
      },
      {
        "line": "      PRIMARY KEY (eid),\n",
        "comment": "Chave primaria da tabela. Se existir mais de uma linha com o mesmo valor, um erro de integridade e' lancado."
      },
      {
        "line": "      UNIQUE (sid, cid));\n",
        "comment": "A palavra-chave UNIQUE e' utilizada para definir um valor unico para cada linha, alem da chave primaria. Valores unicos que podem ser chaves primarias sao chamados de chaves candidatas. Nesse exemplo, o par 'cid' e 'sid' deve ser unico. Um aluno cujo 'sid' e' 1324 pode se matricular na disciplina 'Gerenciamento de Banco de Dados' uma unica vez. No entanto, o aluno pode se matricular em outras disciplinas com diferentes 'cids'. Tambem e' possivel definir uma UNIQUE key como uma restricao."
      },
      {
        "line": "     (eid CHAR(20) NOT NULL, \n",
        "comment": "Essa coluna armazena um identificador para a matricula e e' definida como chave primaria. Por isso, esse valor deve ser unico entre as linhas da tabela."
      }
    ]
  },
  "TableCreation3_version_2_pt": {
    "name": "PrimaryKeyandUniqueKey_pt_v2",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE Enrolled\n",
        "comment": "Tabela para armazenar as matriculas dos alunos. Os alunos podem se matricular apenas uma unica vez em cada disciplina.\n"
      },
      {
        "line": "     (eid CHAR(20) NOT NULL, \n",
        "comment": "Essa coluna armazena um identificador para a matricula e e' definida como chave primaria. Por isso, esse valor deve ser unico entre as linhas da tabela."
      },
      {
        "line": "      sid CHAR(20),\n",
        "comment": "Essa coluna armazena o identificador para o aluno e faz parte de uma chave candidata, definida pela clausula UNIQUE."
      },
      {
        "line": "      cid CHAR(20),\n",
        "comment": "Essa coluna armazena o identificador do curso, que tambem faz parte de uma chave candidata, definida pela clausula UNIQUE."
      },
      {
        "line": "      PRIMARY KEY (eid),\n",
        "comment": "Chave primaria da tabela. Se existir mais de uma linha com o mesmo valor, um erro de integridade e' lancado."
      },
      {
        "line": "      UNIQUE (sid, cid));\n",
        "comment": "A palavra-chave UNIQUE e' utilizada para definir um valor unico para cada linha, alem da chave primaria. Valores unicos que podem ser chaves primarias sao chamados de chaves candidatas. Nesse exemplo, o par 'cid' e 'sid' deve ser unico. Um aluno cujo 'sid' e' 1324 pode se matricular na disciplina 'Gerenciamento de Banco de Dados' uma unica vez. No entanto, o aluno pode se matricular em outras disciplinas com diferentes 'cids'. Tambem e' possivel definir uma UNIQUE key como uma restricao."
      }
    ]
  },
  "TableCreation4_version_1_pt": {
    "name": "ForeignKey_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE Enrolled\n",
        "comment": "Essa tabela armazena as informacoes de matricula dos alunos. Existe uma outra tabela para alunos (Students) cuja chave primaria e' 'sid'."
      },
      {
        "line": "     (sid CHAR(20) NOT NULL,\n",
        "comment": "A coluna 'sid' e' o identificador do aluno. Antes de ser definida como parte da tabela 'Enrolled', ela tambem foi definida na tabela 'Students'."
      },
      {
        "line": "      cid CHAR(20) NOT NULL,\n",
        "comment": "Coluna para armazenar o identificador da disciplina e possui tamanho fixo de 20 caracteres. Essa coluna nao pode conter valores nulos."
      },
      {
        "line": "      grade CHAR(2),\n",
        "comment": "Coluna para armazenar a nota do aluno na disciplina e possui tamanho fixo de 2 caracteres."
      },
      {
        "line": "      PRIMARY KEY (sid,  cid),\n",
        "comment": "Para cada aluno e disciplina, existe uma unica nota."
      },
      {
        "line": "      FOREIGN KEY (sid)\n",
        "comment": "A coluna 'sid' nesta tabela e' uma chave estrangeira que referencia a tabela 'Students'. A clausula FOREIGN KEY identifica o relacionamento da tabela com outras tabelas no banco de dados. As colunas que formam o relacionamento sao chamadas de chave estrangeira."
      },
      {
        "line": "      REFERENCES Students\n",
        "comment": "A palavra REFERENCES e' seguida pelo nome da tabela na qual a chave estrangeira 'sid' referencia. A palavra REFERENCES e' uma parte importante para especificar a tabela relacionada. As palavras-chave FOREIGN KEY e REFERENCES nao devem ser separadas por virgula. Se existir apenas o nome da tabela em seguida, o SGBD considera a chave primaria da tabela como a referencia para a chave estrangeira."
      },
      {
        "line": "      ON DELETE CASCADE\n",
        "comment": "Se uma linha de uma ou mais chaves estrangeiras for apagada, a tupla que contem a chave estrangeira perde a referencia. Nesse exemplo, se o aluno com sid 'ktl123' for apagado na tabela 'Students', a tupla que contem o sid 'ktl123' na tabela 'Enrolled' se torna incapaz de saber as informacoes do aluno, porque perde sua referencia. Perceba que ao excluir uma linha da tabela 'Enrolled' nao causa nenhum problema. Se nenhuma regra for definida explicitamente, o SGBD aplica a regra padrao NO ACTION. <br/> <br/>\nA regra DELETE CASCADE diz ao SGBD para apagar automaticamente as linhas que contem uma chave estrangeira quando uma linha referenciada for apagada."
      },
      {
        "line": "      ON UPDATE SET DEFAULT);",
        "comment": "Se uma chave estrangeira for modificada pela clausula UPDATE, o novo valor deve casar com o valor referenciado na tabela 'Students'. A regra SET DEFAULT diz ao SGBD que, quando um valor de uma linha referenciada por chaves estrangeiras for alterado, os valores da chave estrangeira em todas as linhas correspondetes devem ser alteradas para o valor padrao (default). Essa regra pode ser diferente de acordo com cada banco de dados. Em alguns SGBDs, a regra RESTRICT e' definida como SET NULL. Nesse caso, e' impossivel definir essa regra para uma chave primaria de uma tabela referenciada."
      }
    ]
  },
  "TableCreation7_version_1_pt": {
    "name": "AssertionCreation(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE sailors\n",
        "comment": "Esse exemplo mostra a criacao de uma tabela para marinheiros. Sempre que um novo marinheiro for adicionado deve-se verificar se a soma do numero de marinheiros e o numero de barcos nao sejam maiores que 100. <b>** Esse exemplo esta relacionado com o proximo exemplo.</b>"
      },
      {
        "line": "   (sid INTEGER,\n",
        "comment": ""
      },
      {
        "line": "    sname CHAR(10),\n",
        "comment": ""
      },
      {
        "line": "    rating INTEGER,\n",
        "comment": ""
      },
      {
        "line": "    age REAL,\n",
        "comment": ""
      },
      {
        "line": "    PRIMARY KEY (sid),\n",
        "comment": ""
      },
      {
        "line": "    CHECK\n",
        "comment": "Esse exemplo especifica que o numero total de marinheiros e de barcos deve ser menor que 100. No entanto, esse exemplo esta ERRADO. Esta restricao que verifica ambas as tabelas 'sailors' e 'boats' pertence a tabela 'sailors' recursivamente. Se nao existir nenhum marinheiro (tabela vazia), o numero de barcos podera ser um valor qualquer!"
      },
      {
        "line": "    ((SELECT COUNT(S.sid) \n",
        "comment": "<b>Esse primeiro exemplo esta ERRADO.</b> Se a tabela 'sailors' estiver vazia, o numero de tuplas para os barcos podera ser qualquer coisa! Ela retorna o numero identificador do marinheiro. A consulta mais interna e' executada primeiro."
      },
      {
        "line": "     FROM sailor S) + \n",
        "comment": "Duas consultas diferentes sao ligadas utilizando sinal de adicao (+). Ambos os resultados da consulta sao somados."
      },
      {
        "line": "    (SELECT COUNT(B.sid) \n",
        "comment": "Essa consulta retorna o numero de barcos."
      },
      {
        "line": "     FROM boats B)\n",
        "comment": ""
      },
      {
        "line": "     < 100));\n",
        "comment": "Os resultados somados das duas subconsultas sao comparados com o valor 100. Se o valor da soma for menor que 100, a condicao e' satisfeita e a tupla fara' parte do resultado final."
      }
    ]
  },
  "TableCreation8_version_1_pt": {
    "name": "AssertionCreation(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE ASSERTION smallClub\n",
        "comment": "O exemplo anterior ('Assertion Creation (1)') verifica os valores dentro da propria tabela, o que nao e' apropriado. Esse exemplo explica a utilizacao do comando ASSERTION da forma correta, nao associado com nenhuma tabela. O comando ASSERTION e' uma restricao do banco de dados que limita o conteudo do banco como um todo. Da mesma forma que uma restricao CHECK, uma ASSERTION e' especificada como uma condicao de pesquisa. A diferenca entre as restricoes ASSERTION e CHECK e' que a condicao de pesquisa de uma ASSERTION pode restringir o conteudo de varias tabelas e o relacionamento entre elas. Por isso, uma ASSERTION e' especificada como parte da definicao geral do banco de dados por meio da declaracao CREATE ASSERTION."
      },
      {
        "line": "    CHECK\n",
        "comment": "A palavra-chave 'CHECK' e' obrigatoria na criacao de uma assertion."
      },
      {
        "line": "    ((SELECT COUNT(S.sid) \n",
        "comment": "Nesse exemplo, ambas as tabelas 'sailors' e 'boats' sao tabelas alvo que serao comparadas como uma condicao de busca. Esta linha retorna o numero de marinheiros."
      },
      {
        "line": "     FROM sailors S) + \n",
        "comment": "As duas consultas sao somadas."
      },
      {
        "line": "    (SELECT COUNT(B.sid) \n",
        "comment": "Essa consulta retorna o numero de barcos."
      },
      {
        "line": "     FROM boats B)\n",
        "comment": ""
      },
      {
        "line": "      < 100));\n",
        "comment": "O resultado somado das duas consultas e' comparado com o valor 100, verificando se o valor na tupla e' menor que 100."
      }
    ]
  },
  "TableCreation5_version_1_pt": {
    "name": "CheckConstraint(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE Reserves\n",
        "comment": "Exemplo de criacao da tabela chamada 'Reserves'. Ela contem 3 colunas: sname, bid e day."
      },
      {
        "line": "    (sname CHAR(10),\n",
        "comment": "A coluna 'sname' e' do tipo caractere de tamanho 10."
      },
      {
        "line": "     bid INTEGER,\n",
        "comment": "A coluna 'bid' e' do tipo inteiro."
      },
      {
        "line": "     day DATE,\n",
        "comment": "A coluna 'day' e' do tipo data."
      },
      {
        "line": "     PRIMARY KEY(bid, day),\n",
        "comment": "Um barco so pode ser reservado uma vez por dia."
      },
      {
        "line": "     CONSTRAINT noInterlakeRes\n",
        "comment": "Essa e' a definicao de uma restricao CHECK. Antes de definir a restricao, e' possivel especificar um nome para ela. Neste caso, a restricao foi nomeada como 'noInterlakeRes'."
      },
      {
        "line": "     CHECK\n",
        "comment": "A restricao CHECK e' uma condicao de busca que produz um valor verdadeiro/falso. Quando uma restricao CHECK e' especificada para uma coluna, o SGBD automaticamente verifica o valor daquela coluna toda vez que uma nova linha for inserida ou atualizada para garantir que a condicao de pesquisa seja verdadeira. Uma restricao CHECK de uma coluna e' especificada como parte da definicao da coluna dentro do comando CREATE TABLE."
      },
      {
        "line": "      ('Interlake' <>\n",
        "comment": "Nesse exemplo, a restricao CHECK chamada de 'noInterlakeRes' e' criada para verificar se o nome do barco ('bname') que uma pessoa quer reservar e' \"Interlake\". Serve para limitar a reserva de barco \"Interlake\"."
      },
      {
        "line": "             (SELECT B.bname\n",
        "comment": "Esta subconsulta retorna o nome do barco recuperado da tabela 'boats'."
      },
      {
        "line": "              FROM boats B\n",
        "comment": ""
      },
      {
        "line": "              WHERE B.bid = bid)));\n",
        "comment": "Condicao para ler o nome do barco na tabela 'boats' de acordo com o ID do barco."
      }
    ]
  },
  "TableCreation6_version_1_pt": {
    "name": "CheckConstraint(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE TABLE Sailors\n",
        "comment": "Exemplo de criacao da tabela 'Sailors'. Possui 4 colunas: sid, sname, rating e age."
      },
      {
        "line": "    (sid INTEGER,\n",
        "comment": ""
      },
      {
        "line": "     sname CHAR(10),\n",
        "comment": ""
      },
      {
        "line": "     rating INTEGER,\n",
        "comment": ""
      },
      {
        "line": "     age REAL,\n",
        "comment": ""
      },
      {
        "line": "     PRIMARY KEY (sid),\n",
        "comment": ""
      },
      {
        "line": "     CHECK (rating >= 1 AND rating <= 10));\n",
        "comment": "Em particular, o valor da coluna 'rating' e' restringido entre os valores 1 e 10. Quando uma restricao CHECK e' especificada para um coluna, o SGBD automaticamente verifica o valor da coluna toda vez que uma nova tupla for inserida ou atualizada para garantir que a condicao de pesquisa e' verdadeira."
      }
    ]
  },
  "DataInsertion1_version_1_pt": {
    "name": "InsertingData(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "INSERT INTO Students(sid, name, age)\n",
        "comment": "O aluno 'Jamie Done' que tem 22 anos de idade e numero de matricula '2007001' e' inserido na tabela 'Students'."
      },
      {
        "line": "      VALUES('2007001', 'Jamie Done', 22);\n",
        "comment": "A clausula VALUES define os valores a serem inseridos. A ordem dos valores deve corresponder a ordem das colunas da linha anterior. Se a coluna for do tipo caractere, o valor deve ser estar entre aspas. Nesse exemplo, as colunas 'sid' e 'name' sao do tipo caractere, entao os valores estao entre aspas."
      }
    ]
  },
  "DataInsertion2_version_1_pt": {
    "name": "InsertingData(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "INSERT INTO Students(sid, name, login, age, gpa)\n",
        "comment": "A clausula 'INTO' e' obrigatoria no comando 'INSERT' e serve para especificar a tabela e as colunas em que a nova tupla sera inserida. A ordem de insercao dos dados deve corresponder a ordem especificada nessa clausula. Se o nome das colunas for omitido, os dados sao inseridos na ordem em que as colunas foram definidas na criacao da tabela."
      },
      {
        "line": "      VALUES('53688', 'Smith', 'smith@ee', 18, 3.2);",
        "comment": "A palavra-chave 'VALUES' e' necessaria para definir os dados que serao inseridos. Os valores para 'sid', 'name' e 'login', que sao do tipo caractere, deve ser cercados por aspas."
      }
    ]
  },
  "DataInsertion3_version_1_pt": {
    "name": "InsertingData(3)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "INSERT INTO account\n",
        "comment": "Esse exemplo mostra a insercao de um credito de R$200 na poupanca de todos os clientes com emprestimo na agencia Perryridge. Em vez de especificar dados por usuario, esta consulta utiliza dados lidos de outra tabela. <br/> A tabela 'account' e' definida com as colunas 'account_number', 'branch_name' (agencia) e 'balance' (saldo). Os dados sao armazenados nessa ordem."
      },
      {
        "line": "      SELECT loan_no, branch_name, 200\n",
        "comment": "Antes de executar o comando de insercao, este 'SELECT' e' executado para selecionar os dados que serao armazenados na tabela 'account'. A partir da tabela 'loan' (emprestimo), as colunas 'loan_no' e 'branch_name' sao selecionadas e, para a coluna 'balance' da tabela 'account', a constante 200 e' definida. Assim, todas as contas selecionadas vao ter o saldo de R$200."
      },
      {
        "line": "          FROM loan\n",
        "comment": ""
      },
      {
        "line": "          WHERE branch_name = 'Perryridge';\n",
        "comment": "Essa condicao seleciona apenas as tuplas da agencia 'Perryridge'. O tipo de dados da coluna 'branch_name' e' caractere e, por isso, o valor comparado deve estar entre aspas."
      }
    ]
  },
  "DataInsertion4_version_1_pt": {
    "name": "InsertingData(4)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "INSERT INTO depositor\n",
        "comment": "Exemplo de insercao de dados na tabela 'depositor'."
      },
      {
        "line": "      SELECT customer_name, loan_no\n",
        "comment": "Para atribuir as contas criadas aos clientes da agencia 'Perryridge', o nome do cliente (coluna 'customer_name') na tabela 'borrower' e o numero do emprestimo (coluna 'loan_no') na tabela 'loan' sao selecionados para serem armazenados na tabela 'depositor' (depositante) ."
      },
      {
        "line": "           FROM loan, borrower\n",
        "comment": "'customer_name' pertence a tabela 'borrower' e 'loan_no' pertence a tabela 'loan'. \n\n"
      },
      {
        "line": "           WHERE branch_name ='Perryridge'\n",
        "comment": "Seleciona apenas os clientes da agencia 'Perryridge'."
      },
      {
        "line": "              AND loan.accont_no = borrower.account_no;",
        "comment": "Verifica se cada devedor possui uma conta de emprestimo."
      }
    ]
  },
  "DataDeletion1_version_1_pt": {
    "name": "DeletingData_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "DELETE\n",
        "comment": "O 'DELETE' e' usado para excluir uma ou mais <b>LINHAS</b> de uma tabela.  As palavras-chaves 'DELETE', que define o comando SQL, e 'FROM', que especifica a tabela alvo, sao obrigatorias."
      },
      {
        "line": "      FROM Students;\n",
        "comment": "Clausula para excluir todas as linhas da tabela 'Students'."
      }
    ]
  },
  "DataDeletion2_version_1_pt": {
    "name": "DeletingwithCondition(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "DELETE FROM account\n",
        "comment": "A tabela alvo 'account' e' especificada."
      },
      {
        "line": "     WHERE branch_name IN\n",
        "comment": "A palavra-chave IN e' utilizada para uma operacao de conjuntos. Testa se um dado esta contido em uma lista de valores. Neste exemplo, compara os nomes das agencias com os resultados da subconsulta.\n\n"
      },
      {
        "line": "         (SELECT branch_name\n",
        "comment": "Nesse exemplo, a subconsulta procura por agencias localizadas no 'Brooklyn' para apagar as contas que foram abertas nas agencias retornadas."
      },
      {
        "line": "          FROM branch\n",
        "comment": ""
      },
      {
        "line": "          WHERE branch_city = 'Brooklyn');\n",
        "comment": "A clausula WHERE seleciona as linhas baseado em uma condicao. A palavra-chave 'keyword' e' seguida por uma comparacao. Neste exemplo, seleciona-se as tuplas de agencias que estao localizadas no 'Brooklyn'. A coluna 'branch_city' e' do tipo caractere e, por isso, o valor utilizado na comparacao deve estar entre aspas."
      }
    ]
  },
  "DataDeletion3_version_1_pt": {
    "name": "DeletingwithCondition(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "DELETE FROM account\n",
        "comment": "Esse exemplo mostra a exclusao de tuplas da tabela 'account'."
      },
      {
        "line": "     WHERE balance < \n",
        "comment": "The order of this query execution is firstly, the subquery to calculate the average amount of all account is executed and then the balance of each account is compared with the average. Lastly, the corresponding account is deleted. <br>To limit the data, balance data is compared with the average balance in subquery result.\n\nPrimeiramente, a subconsulta e' executada para calcular o valor medio do saldo das contas e, em seguida, o saldo e' comparado com a media. Por fim, a conta que possui saldo menor que a media e' excluida. "
      },
      {
        "line": "         (SELECT AVG(balance)\n",
        "comment": "Esta subconsulta calcula o valor medio do saldo das contas."
      },
      {
        "line": "          FROM account);\n",
        "comment": ""
      }
    ]
  },
  "DataUpdate3_version_1_pt": {
    "name": "UpdatingData(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "UPDATE Salesrep\n",
        "comment": "A clausula WHERE pode ser omitida caso queira atualizar o valor de uma coluna em TODAS as tuplas. Nesse exemplo, a cota de todos os representantes de vendas e' aumentada em 5%."
      },
      {
        "line": "     SET quota = 1.05 * quota;\n",
        "comment": "Soma 5% no valor da coluna 'quota' de todos os representantes de vendas."
      }
    ]
  },
  "DataUpdate1_version_1_pt": {
    "name": "UpdatingData(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "UPDATE Students S\n",
        "comment": "A palavra-chave 'UPDATE' deve ser seguida pelo nome da tabela (neste caso tabela 'Students'), que foi renomeada para S para nao ser necessario digitar a palavra 'Students' sempre."
      },
      {
        "line": "     SET S.gpa = S.gpa*1.01\n",
        "comment": "A clausula SET e' obrigatoria no comando UPDATE e serve para indicar qual ou quais as colunas serao atualizadas. Como o nome da tabela foi renomeado para S, o nome da coluna deve ser acessado com um ponto (.). Nesta linha, o valor da coluna 'gpa' e' lido, calcula-se 101% do valor e atribui o resultado 'a mesma coluna.  "
      },
      {
        "line": "     WHERE S.gpa >= 3.3;\n",
        "comment": "Nem todas as tuplas sao atualizadas, neste caso. Somente aquelas com valor maior ou igual a 3.3 sao atualizadas."
      }
    ]
  },
  "DataUpdate2_version_1_pt": {
    "name": "UpdatingData(3)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "UPDATE Students S\n",
        "comment": "O comando UPDATE e' utilizado para modificar os valores de uma ou mais colunas das linhas selecionadas."
      },
      {
        "line": "     SET S.age = S.age+1 AND S.gpa = S.gpa-1\n",
        "comment": "A clausula SET especifica uma lista de atribuicoes, sendo que cada atribuicao define o novo valor a ser atualizado."
      },
      {
        "line": "     WHERE S.sid = 5368;\n",
        "comment": "Uma unica tupla ou varias tuplas podem ser atualizadas no mesmo comando, dependendo da condicao definida na clausula WHERE."
      }
    ]
  },
  "DataUpdate4_version_1_pt": {
    "name": "Updatingwithcondition_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "UPDATE Customers\n",
        "comment": "Esse exemplo mostra que mais de uma condicao pode ser definida no mesmo SQL para que mais de uma tupla seja atualizada."
      },
      {
        "line": "     SET cust_rep = 102\n",
        "comment": ""
      },
      {
        "line": "     WHERE cust_rep IN (105, 106, 107);\n",
        "comment": "A palavra-chave IN e' utilizada em operacoes de conjuntos. Ela testa se um valor esta contido em uma lista de valores. Nesse exemplo, se o valor da coluna 'cust_rep' for 105, 106 ou 107 entao a condicao se torna VERDADEIRA e as tuplas sao atualizadas."
      }
    ]
  },
  "DataUpdate5_version_1_pt": {
    "name": "Updatingwithsubquery_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "UPDATE Customers\n",
        "comment": ""
      },
      {
        "line": "     SET credit_limit = credit_limit + 5000.00\n",
        "comment": "Antes de executar o comando UPDATE, a subconsulta em parenteses e' executada para limitar as tuplas a serem atualizadas. Apos isso, um credito de R$ 5000 e' adicionado ao limite atual."
      },
      {
        "line": "     WHERE cust_num IN\n",
        "comment": "A clausula WHERE seleciona um dos clientes na lista de resultados da subconsulta. Geralmente a operacao IN e' utilizada. Ela verifica se cada tupla do resultado da subconsulta e' igual ao valor testado."
      },
      {
        "line": "          (SELECT DISTINCT cust\n",
        "comment": "Essa e' uma subconsulta de selecao (SELECT), uma consulta dentro de outra. Essa consulta retorna a lista de clientes que fizeram compras maiores que 25000. A utilizacao de subconsultas e' interessante quando precisa-se selecionar um conjunto de dados. A subconsulta permite selecionar tuplas a serem atualizadas baseadas em informacoes contidas em outras tabelas."
      },
      {
        "line": "           FROM orders \n",
        "comment": ""
      },
      {
        "line": "           WHERE amount > 25000.00);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection3_version_1_pt": {
    "name": "SelectingAllAttributes_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT * \n",
        "comment": "Por comodidade, pode-se usar o asterisco (*) no lugar da lista de colunas a serem retornadas como se fosse uma abreviacao para \"todas as colunas\"."
      },
      {
        "line": "      FROM Student;",
        "comment": "A clausula 'FROM' define em qual tabela a consulta SQL sera executada."
      }
    ]
  },
  "DataSelection2_version_1_pt": {
    "name": "SelectingMultipleAttributes_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT name, login\n",
        "comment": "Geralmente as colunas a serem retornadas sao especificadas por uma lista separada por virgula. Nesse exemplo, as colunas 'name' e 'login' da tabela 'Students' sao retornadas como resultado da consulta."
      },
      {
        "line": "      FROM Student;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection1_version_1_pt": {
    "name": "SelectingOneAttribute_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT sid \n",
        "comment": "No comando SELECT, as clausulas SELECT e FROM sao obrigatorias. A clausula SELECT especifica a(s) coluna(s) da tabela a ser(em) retornada(s). Os nomes das colunas sao separados por virgula. Nesse exemplo, somente a coluna 'sid' e' selecionada, por isso, nao e' necessario utilizar a virgula."
      },
      {
        "line": "      FROM Student;",
        "comment": "A clausula FROM lista as tabelas que contem as tuplas a serem recuperadas pela consulta. Os dados podem ser recuperados a partir de uma ou varias tabelas."
      }
    ]
  },
  "DataSelection6_version_1_pt": {
    "name": "SelectionCondition_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT Name, Quota, Sales\n",
        "comment": "Essa consulta recupera 3 colunas da tabela 'Salesperson': 'Name', 'Quota' e 'Sales'."
      },
      {
        "line": "      FROM Salesperson\n",
        "comment": ""
      },
      {
        "line": "      WHERE emp_no = 107;",
        "comment": "Essa consulta SQL e' utilizada para recuperar as tuplas relacionadas com a pessoa cujo numero de empregado e' 107. <br/>\nA clausula WHERE e' utilizada para filtrar as linhas retornadas. Ela consiste da palavra-chave WHERE seguida pela condicao de pesquisa. A condicao de pesquisa pode ter 3 resultados: (1) se a condicao for VERDADEIRA, a tupla e' incluida no resultado da consulta; (2) Se a condicao for FALSA, a tupla nao e' incluida no resultado da consulta; e (3) se a condicao tem um valor NULL (valor desconhecido), a tupla nao e' incluida no resultado da consulta. Basicamente, a condicao de pesquisa funciona como um filtro para os registros de uma tabela. Registros que satisfazem a condicao passam pelo filtro e fazem parte do resultado da consulta.\n"
      }
    ]
  },
  "DataSelection4_version_1_pt": {
    "name": "SkippingDuplicates_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT DISTINCT name \n",
        "comment": "A palavra-chave DISTINCT exclui tuplas do resultado da consulta e deve estar localizada antes do nome da coluna cujos valores duplicados serao excluidos. Se a palavra-chave DISTINCT nao for utilizada, o SQL nao exclui as linhas duplicadas e tem o mesmo efeito quando a palavra-chave ALL e' utilizada no lugar."
      },
      {
        "line": "      FROM Student;",
        "comment": ""
      }
    ]
  },
  "DataSelection12_version_1_pt": {
    "name": "ArithmeticExpression_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT loan_number, branch_name, amount * 100\n",
        "comment": "E' possivel recalcular o valor de uma coluna por meio de operacoes aritmeticas, como adicao, subtracao, multiplicacao e divisao. No entanto, o valor da coluna armazenada no banco de dados continua o mesmo e apenas os valores do resultado da consulta sao alterados."
      },
      {
        "line": "     FROM loan;",
        "comment": ""
      }
    ]
  },
  "DataSelection7_version_1_pt": {
    "name": "ComparisonCondition(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT * \n",
        "comment": "Essa consulta retorna todas as colunas da tabela 'Students'."
      },
      {
        "line": "      FROM Student \n",
        "comment": ""
      },
      {
        "line": "      WHERE gpa > 3.2;\n",
        "comment": "A clausula WHERE filtra os resultados. Neste caso, retorna apenas os alunos cujo gpa e' maior que 3.2"
      }
    ]
  },
  "DataSelection8_version_1_pt": {
    "name": "ComparisonCondition(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT City, Sales, Target\n",
        "comment": "Essa consulta retorna as colunas 'City', 'Sales' e 'Target' da tabela 'Offices'."
      },
      {
        "line": "      FROM Offices \n",
        "comment": ""
      },
      {
        "line": "      WHERE Sales < (.8 * Target);\n",
        "comment": "Apenas as vendas menores que 80% do valor da meta (Target). Para processar essa condicao, o SQL cria uma coluna temporaria contendo o valor da expressao (.8 * Target), sendo que 'Target' e' uma das colunas da tabela 'Offices', e entao compara os valores dessa coluna temporaria com os valores da coluna 'Sales'."
      }
    ]
  },
  "DataSelection9_version_1_pt": {
    "name": "ComparisonCondition(3)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT City, Mgr\n",
        "comment": "Essa consulta lista as cidades e os nomes dos gerentes dos escritorios armazenados na tabela 'Offices'."
      },
      {
        "line": "      FROM Offices \n",
        "comment": ""
      },
      {
        "line": "      WHERE Mgr <> 108;\n",
        "comment": "Os resultados excluem as tuplas referentes ao gerente 108. A expressao <> e' utilizada para testar desigualdade. Esta condicao filtra os gerentes cujo numero <b>NAO</b> e' 108."
      }
    ]
  },
  "DataSelecton11_version_1_pt": {
    "name": "MultipleComparisons(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT loan_number \n",
        "comment": ""
      },
      {
        "line": "      FROM loan\n",
        "comment": ""
      },
      {
        "line": "      WHERE branch_name = 'Perryridge' AND amount > 1200;",
        "comment": "Mais de uma condicao pode ser combinada usando os operadores logicos AND, OR e NOT. Nesta linha, a condicao testa se a agencia e' 'Perryridge' <b>E</b> se o montante do emprestimo e' maior que 1200. Ou seja, o resultado sera composto pelas tuplas de emprestimos maiores que 1200 da agencia 'Perryridge'."
      }
    ]
  },
  "DataSelection13_version_1_pt": {
    "name": "MultipleComparisons(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT customer_no, borrower.loan_no, amount\n",
        "comment": "Essa consulta retorna as colunas 'customer_no' e 'amount' da tabela 'loan' e a coluna 'loan_no' da tabela 'borrower'. Note que a coluna 'loan_no' requer o nome da tabela (borrower) como prefixo porque ambas as tabelas 'borrower' e 'loan' possuem uma coluna com o este nome. Se o nome da tabela nao for especificado, a coluna deve ser unica dentre a tabelas contidas na clausula FROM."
      },
      {
        "line": "     FROM borrower, loan\n",
        "comment": "Os dados sao lidos de duas tabelas diferentes."
      },
      {
        "line": "     WHERE borrower.loan_no = loan.loan_no AND branch_name = 'Perryridge';\n",
        "comment": "Para que o valor do emprestimo seja emparelhado corretamente com o cliente, essa condicao testa se o numero do emprestimo (loan_no) e' o mesmo nas duas tabelas. Adicionalmente, apenas os emprestimos da agencia 'Perryridge' sao retornados. Apenas as tuplas que satisfazem as duas condicoes sao retornadas como resultado por causa do operador logico AND."
      }
    ]
  },
  "DataSelection14_version_1_pt": {
    "name": "RangeTest(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT loan_number \n",
        "comment": ""
      },
      {
        "line": "     FROM loan\n",
        "comment": ""
      },
      {
        "line": "     WHERE amount BETWEEN 2000 AND 100000;\n",
        "comment": "A clausula BETWEEN e' um operador de intervalo. O teste de intervalo verifica se o valor da coluna esta entre dois valores especificados. A parte da esquerda da palavra-chave AND representa o limite inferior do intervalo e a parte da direita representa o limite superior do intervalo. Essa clausula e' equivalente 'a (amount >= 2000) AND (amount <=100000)."
      }
    ]
  },
  "DataSelection15_version_1_pt": {
    "name": "RangeTest(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT order_no, date, product, amount\n",
        "comment": ""
      },
      {
        "line": "     FROM orders\n",
        "comment": ""
      },
      {
        "line": "     WHERE date BETWEEN '01-OCT-06' AND '31-DEC-06';\n",
        "comment": "O teste de intervalo tambem pode ser aplicado a datas. Essa clausula e' equivalente a (date >= '01-OCT-06') AND (date <= '31-DEC-06')"
      }
    ]
  },
  "DataSelection17_version_1_pt": {
    "name": "StringOperation_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT customer_name \n",
        "comment": ""
      },
      {
        "line": "     FROM customer\n",
        "comment": ""
      },
      {
        "line": "     WHERE customer_street LIKE '%Main%';",
        "comment": "O SQL possui um operador utilizado para comparar substrings. O operador 'LIKE' utiliza padroes que sao descritos utilizando dois caracteres especiais: <ul><li>porcentagem(%): o caractere % corresponde a qualquer substring. <li>sublinhado(_): o caractere _ corresponde a qualquer caractere.</ul> O simbolo de porcentagem (%) corresponde a qualquer sequencia de zero ou mais caracteres. Nesse exemplo, onde quer que esteja a palavra 'Main' no endereco do cliente (customer_street) resulta na condicao verdadeira. Por exemplo, qualquer um dos seguintes enderecos seriam retornados: Pittsburgh Main Street, Chrismain Blvd, Main Government Bulding, Maine Avenue."
      }
    ]
  },
  "DataSelection10_version_1_pt": {
    "name": "MultipleTableSelection(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT S.name, E.cid \n",
        "comment": "Esse exemplo retorna o nome do aluno e o ID das disciplinas matriculadas."
      },
      {
        "line": "      FROM Student S, Enrolled E\n",
        "comment": "A clausula FROM identifica todas as tabelas que contribuem para o resultado da consulta. Esse SQL retorna dados de duas tabelas - Students e Enrolled. Se uma consulta referencia mais de uma tabela ou o nome da tabela e' muito grande, pode-se utilizar apelidos mais curtos como S ou E para as tabelas em questao. Uma vez que os apelidos sao definidos, deve-se especificar os apelidos das tabelas na lista de colunas a serem retornadas. Nesse exemplo, a coluna 'name' pertence a tabela 'Students' com apelido S e a coluna 'cid' pertence a tabela 'Enrolled' com apelido E."
      },
      {
        "line": "      WHERE S.sid = E.sid AND E.grade = \"A\";\n",
        "comment": "Na condicao da clausula WHERE, os apelidos das tabelas tambem sao utilizados. Nesta linha, a coluna 'cid' e' comparada em ambas as tabelas 'Students' e 'Enrolled'. Alem disso, retorna apenas alunos que obtiveram nota A na disciplina."
      }
    ]
  },
  "DataSelection16_version_1_pt": {
    "name": "MultipleTableSelection(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT customer_name, T.loan_no, S.amount\n",
        "comment": ""
      },
      {
        "line": "     FROM borrower AS T, loan AS S\n",
        "comment": "Os apelidos das tabelas sao definidos na clausula FROM usando a palavra-chave 'AS' (opcional). Se o nome da tabela e' muito grande, torna-se conveniente a utilizacao de um apelido mais curto. Se uma consulta se refere a uma tabela de outro usuario, a tabela tambem pode ter um apelido."
      },
      {
        "line": "     WHERE T.loan_no = S.loan_no;\n",
        "comment": ""
      }
    ]
  },
  "DataSelection18_version_1_pt": {
    "name": "AlphabeticOrder_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT DISTINCT customer_name \n",
        "comment": "A palavra-chave DISTINCT elimina tuplas repetidas. Nesse exemplo, os clientes com emprestimo serao mostrados em ordem alfabetica sem repeticao.\n"
      },
      {
        "line": "     FROM borrower AS T, loan AS S\n",
        "comment": "Os apelidos das tabelas sao definidos para ambas as tabelas, 'borrower' e 'loan'. O apelido pode ser utilizado quando o nome da tabela for muito grande ou por conveniencia do programador."
      },
      {
        "line": "     WHERE T.loan_no = S.loan_no\n",
        "comment": "Condicao para realizar a correspondencia do numero do emprestimo (loan_no) nas duas tabelas."
      },
      {
        "line": "     ORDER BY customer_name;",
        "comment": "Pode-se definir a coluna a ser ordenada utilizando a clausula 'ORDER BY'. Para ordenar de forma decrescente, utilize a palavra-chave DESC e para ordenar de forma ascendente utilize a palavra-chave ASC. Essas palavras podem ser colocadas apos o nome da coluna. Por padrao, a ordenacao acontece de forma ascendente."
      }
    ]
  },
  "DataSelection19_version_1_pt": {
    "name": "CombiningQueryResults(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "(SELECT customer_name \n",
        "comment": "Este primeiro SELECT seleciona os clientes que possuem conta."
      },
      {
        "line": "     FROM depositor)\n",
        "comment": ""
      },
      {
        "line": "     UNION\n",
        "comment": "A operacao UNION combina os resultados de duas ou mais consultas em uma unica tabela de resultado. A principal restricao da operacao UNION e' que as subconsultas devem possuir o mesmo numero de colunas retornadas e tambem os tipos de dados das colunas devem coincidir. Como a operacao UNION combina dois ou mais conjuntos de resultados, o resultado final pode conter linhas repetidas. Entretanto, <u>por padrao</u>, a operacao UNION elimina as linhas duplicadas como parte de seu processamento. Caso queira manter as linhas duplicadas, a palavra-chave ALL pode ser utilizada depois da palavra UNION, como 'UNION ALL'."
      },
      {
        "line": "(SELECT customer_name \n",
        "comment": "Este segundo SELECT retorna os clientes que possuem algum emprestimo."
      },
      {
        "line": "     FROM borrower);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection20_version_1_pt": {
    "name": "CombiningQueryResults(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "(SELECT customer_name\n",
        "comment": "Esta primeira consulta retorna os clientes que possuem conta."
      },
      {
        "line": "     FROM depositor)\n",
        "comment": ""
      },
      {
        "line": "     INTERSECT\n",
        "comment": "A operacao INTERSECT produz uma unica tabela com as tuplas que aparecem nos resultados das outras consultas. O resultado das duas consultas deve possuir o mesmo numero de colunas e com mesmos tipos de dados. <u>Por padrao</u>, a operacao INTERSECT elimina as linhas repetidas. Caso queira manter as linhas repetidas, a palavra-chave ALL pode ser usada depois da palavra INTERSECT, como 'INTERSECT ALL'."
      },
      {
        "line": "(SELECT customer_name \n",
        "comment": "Esta consulta retorna os clientes que possuem algum emprestimo."
      },
      {
        "line": "     FROM borrower);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection21_version_1_pt": {
    "name": "CombiningQueryResults(3)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "(SELECT customer_name \n",
        "comment": "Esta consulta retorna os clientes que possuem conta.\n"
      },
      {
        "line": "     FROM depositor)\n",
        "comment": ""
      },
      {
        "line": "     EXCEPT\n",
        "comment": "O operador EXCEPT produz um unica tabela contendo as tuplas que aparecem no resultado da primeira consulta mas nao aparecem no resultado da segunda consulta. Note que o resultado das duas consultas devem possuir o mesmo numero de colunas e com os mesmos tipos de dados. <u>Por padrao</u>, o operador EXCEPT elimina as linhas duplicadas. Caso queira manter as linhas duplicadas, deve-se utilizar a palavra-chave ALL depois da palavra EXCEPT, como 'EXCEPT ALL'."
      },
      {
        "line": "     (SELECT customer_name\n",
        "comment": "Esta consulta retorna os clientes que possuem algum emprestimo."
      },
      {
        "line": "     FROM borrower);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection30_version_1_pt": {
    "name": "ComparingSubqueryResults(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT branch_name \n",
        "comment": ""
      },
      {
        "line": "     FROM branch\n",
        "comment": ""
      },
      {
        "line": "     WHERE assets > SOME\n",
        "comment": "O teste utilizando SOME e' usado em conjunto com um dos seis operadores SQL de comparacao (=, <>, <, <=, >, >=) para comparar o valor de teste com os resultados da subconsulta. Se alguma das comparacoes individuais leva a um resultado VERDADEIRO, o teste SOME retorna um valor VERDADEIRO. Os operadores SOME e ANY sao equivalentes. Nesse exemplo, o ativos de cada agencia e' comparado com todos os ativos das agencias do 'Brooklyn'."
      },
      {
        "line": "          (SELECT assets \n",
        "comment": "Esta consulta retorna os ativos das agencias do 'Brooklyn'."
      },
      {
        "line": "           FROM branch \n",
        "comment": ""
      },
      {
        "line": "          WHERE branch_city = 'Brooklyn');\n",
        "comment": ""
      }
    ]
  },
  "DataSelection31_version_1_pt": {
    "name": "ComparingSubqueryResults(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT branch_name \n",
        "comment": ""
      },
      {
        "line": "     FROM branch\n",
        "comment": ""
      },
      {
        "line": "     WHERE assets > ALL\n",
        "comment": "O teste utilizando ALL e' usado em conjunto com um dos seis operadores SQL de comparacao (=, <>, <, <=, >, >=) para comparar o valor de teste com os resultados da subconsulta. Se todas as comparacoes individuais leva a um resultado VERDADEIRO, o teste ALL retorna um valor VERDADEIRO. Nesse exemplo, o ativo de cada agencia e' comparado com todos os ativos das agencias do 'Brooklyn' e se TODOS os valores das agencias do 'Brooklyn' forem menores que o ativo da agencia comparada, a tupla e' retornada como resultado."
      },
      {
        "line": "          (SELECT assets \n",
        "comment": "Esta consulta retorna os ativos das agencias do 'Brooklyn'."
      },
      {
        "line": "           WHERE branch_city = Brooklyn);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection27_version_1_pt": {
    "name": "CheckingNullValues_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT loan_no \n",
        "comment": ""
      },
      {
        "line": "     FROM loan\n",
        "comment": ""
      },
      {
        "line": "     WHERE amount IS NULL;\n",
        "comment": "O predicado IS NULL e' utilizado para comparar valores nulos. Se o valor comparado e' nulo, a condicao retorna o resultado VERDADEIRO e vice-versa. NULL e' apenas uma palavra-chave para indicar um valor desconhecido. Mesmo que a comparacao 'amount = null' fosse correta, as regras seriam diferentes do que esperamos. Uma comparacao como essa seria 'Valor Conhecido = Valor Desconhecido', o que e' impossivel de julgar se e' VERDADEIRO ou FALSO."
      }
    ]
  },
  "DataSelection25_version_1_pt": {
    "name": "GroupedQueries_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT branch_name, AVG(balance)\n",
        "comment": "Usando o GROUP BY para agrupar os resultados por agencia."
      },
      {
        "line": "     FROM account\n",
        "comment": ""
      },
      {
        "line": "     GROUP BY branch_name;",
        "comment": "A clausula GROUP BY e' usada para agrupar os dados da tabela em uma unica tupla para cada grupo. Nesse exemplo, os resultados sao agrupados pelo nome das agencias (branch_name)."
      }
    ]
  },
  "DataSelection26_version_1_pt": {
    "name": "GroupedQuerieswithCondition_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT branch_name, AVG(balance)\n",
        "comment": ""
      },
      {
        "line": "     FROM account\n",
        "comment": ""
      },
      {
        "line": "     GROUP BY branch_name\n",
        "comment": "O resultado e' agrupado e condensado para cada nome de agencia (branch_name)."
      },
      {
        "line": "     HAVING AVG(balance) > 600;\n",
        "comment": "Assim como a clausula WHERE, a clausula HAVING pode ser utilizada para selecionar e excluir linhas de determinados grupos. <br/> Conforme especificado pelo GROUP BY, a informacao de saldo e' agrupada e totalizada por nome de agencia e entao a media dos saldos e' calculada. Se a media dos subtotal for maior que 600, entao a tupla e' retornada. O formato da clausula HAVING e' similar ao formato da clausula WHERE, mas a clausula HAVING pode ser usada como um grupo."
      }
    ]
  },
  "DataSelection32_version_1_pt": {
    "name": "AggregatingSubquery_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT branch_name \n",
        "comment": "Primeiro, o valor medio de todas as agencias e' calculado em uma subconsulta e entao, utilizando o teste ALL, o valor medio por conta de cada agencia e' comparado aos resultados da subconsulta."
      },
      {
        "line": "     FROM account\n",
        "comment": "Recuperando as agencias com maior media de saldo entre as contas."
      },
      {
        "line": "     GROUP BY branch_name\n",
        "comment": "Esta linha agrupa o saldo das contas de acordo com o nome das agencias."
      },
      {
        "line": "     HAVING AVG(balance) >= ALL \n",
        "comment": "Essa condicao procura a maior media de saldo utilizando o teste ALL. Da mesma forma que a clausula WHERE e' utilizada para selecionar e elimitar linhas individuais, a clausula HAVING e' utilizada para selecionar e eliminar linhas agrupadas. O formato da clausula HAVING e' parecido com o formato da clausula WHERE, mas a clausula HAVING pode se usada como uma condicao de busca em grupos. Para que a comparacao >= seja realizada, o saldo e' agrupado pelo nome da agencia e a media e' calculada. O valor unico calculado e' comparado com todas as medias das agencias e se todos forem menores ou iguais ao valor comparado, a condicao retorna o resultado VERDADEIRO, fazendo com que a tupla pertenca ao resultado final."
      },
      {
        "line": "          (SELECT AVG(balance) \n",
        "comment": "Esta linha calcula a media do saldo das contas de cada agencia."
      },
      {
        "line": "           FROM account \n",
        "comment": ""
      },
      {
        "line": "           GROUP BY branch_name);\n",
        "comment": "Especifica o agrupamento do saldo pelo nome das agencias e para que o valor agrupado possa ser calculado pela funcao AVG."
      }
    ]
  },
  "DataSelection36_version_1_pt": {
    "name": "Groupingandaggregating(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT b.bid, COUNT(*) AS account\n",
        "comment": ""
      },
      {
        "line": "     FROM boats B, reserves R\n",
        "comment": "As tabelas 'boats' e 'reserves' sao apelidadas de B e R, respectivamente."
      },
      {
        "line": "     WHERE R.bid = B.bid AND b.color = red\n",
        "comment": "Essa condicao testa se os barcos ja foram reservados por meio da ligacao do ID do barco na tabela 'boats' e na tabela 'reserves'. Alem disso, retorna apenas os barcos de cor vermelha."
      },
      {
        "line": "     GROUP BY B.bid;\n",
        "comment": "A funcao COUNT esta trabalhando juntamente com a clausula GROUP BY. Para calcular o numero de linhas, primeiro o resultado e' agrupado pelo ID do barco (bid). Entao, a funcao COUNT e' executada."
      }
    ]
  },
  "DataSelection37_version_1_pt": {
    "name": "Groupingandaggregating(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT S.rating, MIN (S.age)\n",
        "comment": ""
      },
      {
        "line": "     FROM Sailor S\n",
        "comment": ""
      },
      {
        "line": "     WHERE S.age > 18\n",
        "comment": "Nessa consulta, nem todos os marinheiros sao considerados. Apenas aqueles com idade maior que 18 anos sao selecionados."
      },
      {
        "line": "     GROUP BY S.rating\n",
        "comment": "As avaliacoes dos marinheiros sao agrupadas."
      },
      {
        "line": "     HAVING 1 < \n",
        "comment": "Essa consulta primeiro limita as avaliacoes que contem pelo menos 2 marinheiros. O numero total de cada avaliacao que os marinheiros pertencem e' comparado com o valor 1."
      },
      {
        "line": "         (SELECT COUNT(*) \n",
        "comment": "Essa subconsulta conta o numero de marinheiros pertencentes a cada avaliacao."
      },
      {
        "line": "          FROM Sailors S2\n",
        "comment": ""
      },
      {
        "line": "          WHERE S.rating = S2.rating);\n",
        "comment": "As avaliacoes (ratings) na tabela 'Sailors' sao relacionadas com as avaliacoes agrupadas na consulta principal."
      }
    ]
  },
  "DataSelection38_version_1_pt": {
    "name": "Groupingandaggregating(3)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT S.rating \n",
        "comment": ""
      },
      {
        "line": "     FROM Sailor S\n",
        "comment": ""
      },
      {
        "line": "     WHERE S.age = \n",
        "comment": ""
      },
      {
        "line": "         (SELECT MIN (AVG(S2.age)) \n",
        "comment": "Esse exemplo esta ERRADO porque as operacoes de agregacao nao podem ser aninhadas. Essa consulta tentava calcular a media da idade dos marinheiros e o valor minimo. A funcao AVG nao pode ser aninhada com nenhuma outra funcao de agregacao."
      },
      {
        "line": "          FROM sailors S2);",
        "comment": ""
      }
    ]
  },
  "DataSelection28_version_1_pt": {
    "name": "NestedSubqueries(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT DISTINCT customer_name \n",
        "comment": "A subconsulta entre parenteses e' executada primeiro e entao usando o operador de conjunto IN, os resultados sao comparados com os resultados da consulta principal. <br/> Colocando a palavra-chave DISTINCT, os nomes de clientes (customer_name) duplicados serao removidos."
      },
      {
        "line": "     FROM borrower\n",
        "comment": ""
      },
      {
        "line": "     WHERE customer_name IN \n",
        "comment": "O operador IN verifica se o dado esta contido na lista retornada pela subconsulta. Por exemplo, 'X IN (A, B, C)' e' a mesma coisa que '(X = A) OR (X = B) OR (X = C)'. Nesse exemplo, verifica-se se o nome do cliente (customer_name) esta na tabela 'depositor'."
      },
      {
        "line": "          (SELECT customer_name \n",
        "comment": "O SQL possui um mecanismo para aninhar subconsultas. Uma subconsulta e' uma declaracao SELECT-FROM-WHERE ou uma declaracao com as clausulas GROUP BY ou HAVING aninhadas dentro de uma outra consulta. <br/> Nesse exemplo, essa subconsulta retorna os nomes dos clientes que possuem conta."
      },
      {
        "line": "           FROM depositor);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection29_version_1_pt": {
    "name": "NestedSubqueries(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT DISTINCT customer_name \n",
        "comment": "Clientes que possuem conta sao selecionados na subconsulta e depois os clientes que possuem algum emprestimo sao comparados com o resultado da subconsulta."
      },
      {
        "line": "     FROM borrower\n",
        "comment": ""
      },
      {
        "line": "     WHERE customer_name NOT IN \n",
        "comment": "Na condicao da clausula WHERE, o operador NOT IN pode ser usado para verificar se o dado NAO esta no resultado da subconsulta."
      },
      {
        "line": "          (SELECT customer_name \n",
        "comment": "Esta subconsulta retorna o nome dos clientes que possuem conta."
      },
      {
        "line": "           FROM depositor);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection33_version_1_pt": {
    "name": "DerivedRelations_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT branch_name, avg_balance\n",
        "comment": "Nesse exemplo, uma subconsulta derivada e' usada na clausula FROM. Os nomes das colunas retornadas pela consulta principal nao e' mais da tabela original 'account'. Agora os nomes sao apelidos vindos da subconsulta derivada."
      },
      {
        "line": "     FROM\n",
        "comment": "O SQL permite que uma subconsulta seja utilizada na clausula FROM, chamada de tabela derivada."
      },
      {
        "line": "          (SELECT branch_name, AVG(balance)\n",
        "comment": "Essa subconsulta seleciona o nome e a media de saldo das contas das agencias."
      },
      {
        "line": "           FROM account\n",
        "comment": "Observe que nao e' necessario usar a clausula HAVING, visto que a tabela temporaria <i>branch_avg</i> e' calculada na clausula FROM e os atributos da tabela temporaria <i>branch_avg</i> podem ser utilizados diretamente na clausula WHERE."
      },
      {
        "line": "           GROUP BY branch_name)\n",
        "comment": "Essa clausula GROUP BY e' usada na tabela derivada."
      },
      {
        "line": "           AS branch_avg(branch_name, avg_balance))\n",
        "comment": "A subconsulta derivada e suas duas colunas sao renomeadas usando uma tupla. Portanto, a subconsulta e' chamada de 'branch_avg', a primeira coluna de 'branch_name' e a segunda coluna de 'avg_balance'."
      },
      {
        "line": "    WHERE avg_balance > 1200;\n",
        "comment": "Para limitar o valor da coluna 'avg_balance', a clausula WHERE e' utilizada. Nao e' necessario utilizar a clausula HAVING, visto que a subconsulta derivada gera uma tabela temporaria e o valor testado, avg_balance, pode ser lido diretamente dessa tabela."
      }
    ]
  },
  "DataSelection41_version_1_pt": {
    "name": "AggregatingDerivedRelations_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT temp.rating, temp.average\n",
        "comment": "Para que o exemplo anterior fique correto, tabelas derivadas e comparacao usando a clausula WHERE podem ser utilizadas. Esse exemplo tambem e' usado para recuperar as avaliacoes cuja media de idade e' o menor valor das avaliacoes. O prefixo 'temp' no nome das colunas vem do nome da tabela derivada."
      },
      {
        "line": "     FROM \n",
        "comment": ""
      },
      {
        "line": "        (SELECT S.rating, AVG(S.age) AS avgage\n",
        "comment": "Essa subconsulta e' usada dentro da clausula FROM da consulta principal, chamada de tabela derivada. Ela calcula a media de idade dos marinheiros para cada avaliacao. Os marinheiros sao agrupados pelas avaliacoes e a media de idade e' calculada em cada grupo. A coluna que contem o valor da media e' renomeada para 'avgage'."
      },
      {
        "line": "         FROM sailors S\n",
        "comment": ""
      },
      {
        "line": "         GROUP BY S.rating) AS temp\n",
        "comment": "A subconsulta derivada e' renomeada para 'temp'. Uma vez que foi renomeada, o novo nome pode ser usado nas consultas externas."
      },
      {
        "line": "     WHERE temp.avgage = \n",
        "comment": "Os valores da coluna 'avgage' na tabela derivada sao comparados com a segunda subconsulta."
      },
      {
        "line": "    (SELECT MIN(temp.avgage) \n",
        "comment": "Esta consulta calcula o valor minimo entre as medias de idade ('avgage') da tabela derivada, 'temp'."
      },
      {
        "line": "     FROM temp);\n",
        "comment": ""
      }
    ]
  },
  "DataSelection34_version_1_pt": {
    "name": "ViewCreation(1)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE VIEW v AS \n",
        "comment": "Uma VIEW e' uma tabela virtual no banco de dados cujo conteudo e' definido por uma consulta. Para os usuarios, uma VIEW parece ser uma tabela real, mas as linhas e as colunas visiveis atraves da VIEW sao, na verdade, o resultado de uma consulta que define a VIEW. O comando SQL para criar uma nova VIEW deve comecar com 'CREATE VIEW' seguido pelo nome da view. As colunas da view sao definidas depois da palavra-chave 'AS'."
      },
      {
        "line": "     (SELECT customer_name, loan_no \n",
        "comment": "Esta e' a consulta que define a VIEW e retorna o nome e o ID do emprestimo dos clientes que possuem algum emprestimo."
      },
      {
        "line": "      FROM borrower, loan\n",
        "comment": "Quando o SGBD encontra uma referencia para uma view em uma declaracao SQL, ele encontra a definicao da view e, entao, o SGBD traduz a requisicao que referencia a view em uma requisicao equivalente diretamente nas tabelas e a executa."
      },
      {
        "line": "      WHERE borrower.loan_no = loan.loan_no);\n",
        "comment": "As VIEWS fornecem varios beneficios e podem ser uteis em diferentes tipos de bancos de dados. Seus principais beneficios sao: <ul><li>Seguranca: Os usuarios podem ter permissao para acessar o banco de dados apenas por meio de um pequeno conjunto de views.</li><li>Simplicidade de consulta: Uma view pode conter dados de diversas tabelas e apresenta-los em uma unica tabela, fazendo com que consultas multitable se tornem consultas em uma unica tabela.</li><li>Simplicidade estrutural: Views podem dar aos usuarios uma visao personalizada do banco de dados.</li><li>Isolamento de mudancas: Uma view pode apresentar uma imagem consistente e sem alteracoes da estrutura do banco de dados, mesmo que as tabelas de origem sejam divididas, reestruturadas ou renomeadas.</li><li>Integridade de dados: Se os dados sao acessados e inseridos atraves de views, o SGBD consegue verificar automaticamente os dados para garantir restricoes de integridade especificadas.</li></ul>Enquanto as views proporcionam vantagens significativas, existem dois grandes inconvenientes: <ul><li>Desempenho: Se a view for definida por uma consulta multitable complexa entao uma simples consulta nessa view se torna uma juncao complicada e pode demorar muito tempo para ser executada.</li><li>Restricoes de atualizacao: Atualizar tuplas de uma view e' possivel apenas para views simples e views mais complexas nao podem ser atualizadas; elas sao somente leitura.</li></ul>"
      }
    ]
  },
  "DataSelection40_version_1_pt": {
    "name": "Retrievingdatafromview_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "SELECT customer_name\n",
        "comment": ""
      },
      {
        "line": "      FROM all_customer\n",
        "comment": "A view nomeada 'all_customer' e' usada no lugar de uma tabela real."
      },
      {
        "line": "      WHERE branch_name = 'Perryridge';\n",
        "comment": "Os resultados se restringem aos clientes pertencentes 'a agencia 'Perryridge'."
      }
    ]
  },
  "DataSelection35_version_1_pt": {
    "name": "ViewCreation(2)_pt",
    "description": "This is the portuguese version.",
    "language": "sql",
    "author": "rafael.araujo",
    "lines": [
      {
        "line": "CREATE VIEW all_customer AS \n",
        "comment": "Uma VIEW e' uma tabela virtual no banco de dados cujo conteudo e' definido por uma consulta. Para os usuarios, uma VIEW parece ser uma tabela real, mas as linhas e as colunas visiveis atraves da VIEW sao, na verdade, o resultado de uma consulta que define a VIEW."
      },
      {
        "line": "    (SELECT branch_name, customer_name\n",
        "comment": "Essa primeira consulta retorna a agencia e o nome dos clientes que possuem contas."
      },
      {
        "line": "        FROM depositor, account\n",
        "comment": ""
      },
      {
        "line": "        WHERE depositor.account_no = account.account_no)\n",
        "comment": ""
      },
      {
        "line": "     UNION\n",
        "comment": "Uma VIEW geralmente e' uma combinacao de varias tabelas. Portanto, usar o operador UNION permite adicionar resultados de duas consultas SQL diferentes. UNION e' a combinacao de dois resultados de consultas diferentes em um unico resultado sem repeticao."
      },
      {
        "line": "    (SELECT branch_name, customer_name\n",
        "comment": "Esta segunda consulta retorna a agencia e o nome dos clientes que possuem algum emprestimo."
      },
      {
        "line": "        FROM borrower, loan\n",
        "comment": ""
      },
      {
        "line": "        WHERE borrower.loan_no = loan.loan_no);\n",
        "comment": ""
      }
    ]
  },
  "LeftJoin25_1": {
    "name": "Left Join 1",
    "description": "",
    "language": "sql",
    "author": "",
    "lines": [
      {
        "line": "SELECT * FROM Students;",
        "comment": ""
      },
      {
        "line": "",
        "comment": ""
      }
    ]
  },
  "LeftJoin25_1_version_1": {
    "name": "LeftJoin1_version_1",
    "description": "",
    "language": "sql",
    "author": "",
    "lines": [
      {
        "line": "SELECT Customers.CustomerName, Orders.OrderID",
        "comment": ""
      },
      {
        "line": "FROM Customers\nLEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID",
        "comment": "The LEFT JOIN keyword returns all records from the left table (Customers), even if there are no matches in the right table (Orders). This returns the list of all customers' orders. However, in contrast to INNER JOIN, which will not show customers without orders, LEFT JOIN will show those customers and NULL in their orders-related columns."
      }
    ]
  }
}